// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team11/app/ent/author"
	"github.com/team11/app/ent/book"
	"github.com/team11/app/ent/bookborrow"
	"github.com/team11/app/ent/booking"
	"github.com/team11/app/ent/bookreturn"
	"github.com/team11/app/ent/category"
	"github.com/team11/app/ent/cliententity"
	"github.com/team11/app/ent/location"
	"github.com/team11/app/ent/preemption"
	"github.com/team11/app/ent/purpose"
	"github.com/team11/app/ent/research"
	"github.com/team11/app/ent/researchtype"
	"github.com/team11/app/ent/role"
	"github.com/team11/app/ent/roominfo"
	"github.com/team11/app/ent/servicepoint"
	"github.com/team11/app/ent/status"
	"github.com/team11/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthor       = "Author"
	TypeBook         = "Book"
	TypeBookborrow   = "Bookborrow"
	TypeBooking      = "Booking"
	TypeBookreturn   = "Bookreturn"
	TypeCategory     = "Category"
	TypeClientEntity = "ClientEntity"
	TypeLocation     = "Location"
	TypePreemption   = "Preemption"
	TypePurpose      = "Purpose"
	TypeResearch     = "Research"
	TypeResearchtype = "Researchtype"
	TypeRole         = "Role"
	TypeRoominfo     = "Roominfo"
	TypeServicePoint = "ServicePoint"
	TypeStatus       = "Status"
	TypeUser         = "User"
)

// AuthorMutation represents an operation that mutate the Authors
// nodes in the graph.
type AuthorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	clearedFields map[string]struct{}
	owner         map[int]struct{}
	removedowner  map[int]struct{}
	writer        map[int]struct{}
	removedwriter map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Author, error)
}

var _ ent.Mutation = (*AuthorMutation)(nil)

// authorOption allows to manage the mutation configuration using functional options.
type authorOption func(*AuthorMutation)

// newAuthorMutation creates new mutation for $n.Name.
func newAuthorMutation(c config, op Op, opts ...authorOption) *AuthorMutation {
	m := &AuthorMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorID sets the id field of the mutation.
func withAuthorID(id int) authorOption {
	return func(m *AuthorMutation) {
		var (
			err   error
			once  sync.Once
			value *Author
		)
		m.oldValue = func(ctx context.Context) (*Author, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Author.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthor sets the old Author of the mutation.
func withAuthor(node *Author) authorOption {
	return func(m *AuthorMutation) {
		m.oldValue = func(context.Context) (*Author, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AuthorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *AuthorMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *AuthorMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Author.
// If the Author object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AuthorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *AuthorMutation) ResetName() {
	m._Name = nil
}

// AddOwnerIDs adds the owner edge to Research by ids.
func (m *AuthorMutation) AddOwnerIDs(ids ...int) {
	if m.owner == nil {
		m.owner = make(map[int]struct{})
	}
	for i := range ids {
		m.owner[ids[i]] = struct{}{}
	}
}

// RemoveOwnerIDs removes the owner edge to Research by ids.
func (m *AuthorMutation) RemoveOwnerIDs(ids ...int) {
	if m.removedowner == nil {
		m.removedowner = make(map[int]struct{})
	}
	for i := range ids {
		m.removedowner[ids[i]] = struct{}{}
	}
}

// RemovedOwner returns the removed ids of owner.
func (m *AuthorMutation) RemovedOwnerIDs() (ids []int) {
	for id := range m.removedowner {
		ids = append(ids, id)
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
func (m *AuthorMutation) OwnerIDs() (ids []int) {
	for id := range m.owner {
		ids = append(ids, id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *AuthorMutation) ResetOwner() {
	m.owner = nil
	m.removedowner = nil
}

// AddWriterIDs adds the writer edge to Book by ids.
func (m *AuthorMutation) AddWriterIDs(ids ...int) {
	if m.writer == nil {
		m.writer = make(map[int]struct{})
	}
	for i := range ids {
		m.writer[ids[i]] = struct{}{}
	}
}

// RemoveWriterIDs removes the writer edge to Book by ids.
func (m *AuthorMutation) RemoveWriterIDs(ids ...int) {
	if m.removedwriter == nil {
		m.removedwriter = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwriter[ids[i]] = struct{}{}
	}
}

// RemovedWriter returns the removed ids of writer.
func (m *AuthorMutation) RemovedWriterIDs() (ids []int) {
	for id := range m.removedwriter {
		ids = append(ids, id)
	}
	return
}

// WriterIDs returns the writer ids in the mutation.
func (m *AuthorMutation) WriterIDs() (ids []int) {
	for id := range m.writer {
		ids = append(ids, id)
	}
	return
}

// ResetWriter reset all changes of the "writer" edge.
func (m *AuthorMutation) ResetWriter() {
	m.writer = nil
	m.removedwriter = nil
}

// Op returns the operation name.
func (m *AuthorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Author).
func (m *AuthorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AuthorMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, author.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AuthorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case author.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AuthorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case author.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Author field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AuthorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case author.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Author field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AuthorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AuthorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AuthorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Author numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AuthorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AuthorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Author nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AuthorMutation) ResetField(name string) error {
	switch name {
	case author.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Author field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AuthorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, author.EdgeOwner)
	}
	if m.writer != nil {
		edges = append(edges, author.EdgeWriter)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AuthorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case author.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.owner))
		for id := range m.owner {
			ids = append(ids, id)
		}
		return ids
	case author.EdgeWriter:
		ids := make([]ent.Value, 0, len(m.writer))
		for id := range m.writer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AuthorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedowner != nil {
		edges = append(edges, author.EdgeOwner)
	}
	if m.removedwriter != nil {
		edges = append(edges, author.EdgeWriter)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AuthorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case author.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.removedowner))
		for id := range m.removedowner {
			ids = append(ids, id)
		}
		return ids
	case author.EdgeWriter:
		ids := make([]ent.Value, 0, len(m.removedwriter))
		for id := range m.removedwriter {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AuthorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AuthorMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AuthorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Author unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AuthorMutation) ResetEdge(name string) error {
	switch name {
	case author.EdgeOwner:
		m.ResetOwner()
		return nil
	case author.EdgeWriter:
		m.ResetWriter()
		return nil
	}
	return fmt.Errorf("unknown Author edge %s", name)
}

// BookMutation represents an operation that mutate the Books
// nodes in the graph.
type BookMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_BookName       *string
	clearedFields   map[string]struct{}
	category        *int
	clearedcategory bool
	author          *int
	clearedauthor   bool
	user            *int
	cleareduser     bool
	status          *int
	clearedstatus   bool
	booklist        map[int]struct{}
	removedbooklist map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Book, error)
}

var _ ent.Mutation = (*BookMutation)(nil)

// bookOption allows to manage the mutation configuration using functional options.
type bookOption func(*BookMutation)

// newBookMutation creates new mutation for $n.Name.
func newBookMutation(c config, op Op, opts ...bookOption) *BookMutation {
	m := &BookMutation{
		config:        c,
		op:            op,
		typ:           TypeBook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookID sets the id field of the mutation.
func withBookID(id int) bookOption {
	return func(m *BookMutation) {
		var (
			err   error
			once  sync.Once
			value *Book
		)
		m.oldValue = func(ctx context.Context) (*Book, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Book.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBook sets the old Book of the mutation.
func withBook(node *Book) bookOption {
	return func(m *BookMutation) {
		m.oldValue = func(context.Context) (*Book, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BookMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBookName sets the BookName field.
func (m *BookMutation) SetBookName(s string) {
	m._BookName = &s
}

// BookName returns the BookName value in the mutation.
func (m *BookMutation) BookName() (r string, exists bool) {
	v := m._BookName
	if v == nil {
		return
	}
	return *v, true
}

// OldBookName returns the old BookName value of the Book.
// If the Book object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookMutation) OldBookName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBookName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBookName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookName: %w", err)
	}
	return oldValue.BookName, nil
}

// ResetBookName reset all changes of the "BookName" field.
func (m *BookMutation) ResetBookName() {
	m._BookName = nil
}

// SetCategoryID sets the category edge to Category by id.
func (m *BookMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the category edge to Category.
func (m *BookMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared returns if the edge category was cleared.
func (m *BookMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the category id in the mutation.
func (m *BookMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the category ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *BookMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory reset all changes of the "category" edge.
func (m *BookMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// SetAuthorID sets the author edge to Author by id.
func (m *BookMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the author edge to Author.
func (m *BookMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared returns if the edge author was cleared.
func (m *BookMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the author id in the mutation.
func (m *BookMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the author ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *BookMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor reset all changes of the "author" edge.
func (m *BookMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetUserID sets the user edge to User by id.
func (m *BookMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *BookMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *BookMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *BookMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BookMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *BookMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetStatusID sets the status edge to Status by id.
func (m *BookMutation) SetStatusID(id int) {
	m.status = &id
}

// ClearStatus clears the status edge to Status.
func (m *BookMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared returns if the edge status was cleared.
func (m *BookMutation) StatusCleared() bool {
	return m.clearedstatus
}

// StatusID returns the status id in the mutation.
func (m *BookMutation) StatusID() (id int, exists bool) {
	if m.status != nil {
		return *m.status, true
	}
	return
}

// StatusIDs returns the status ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *BookMutation) StatusIDs() (ids []int) {
	if id := m.status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus reset all changes of the "status" edge.
func (m *BookMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
}

// AddBooklistIDs adds the booklist edge to Bookborrow by ids.
func (m *BookMutation) AddBooklistIDs(ids ...int) {
	if m.booklist == nil {
		m.booklist = make(map[int]struct{})
	}
	for i := range ids {
		m.booklist[ids[i]] = struct{}{}
	}
}

// RemoveBooklistIDs removes the booklist edge to Bookborrow by ids.
func (m *BookMutation) RemoveBooklistIDs(ids ...int) {
	if m.removedbooklist == nil {
		m.removedbooklist = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooklist[ids[i]] = struct{}{}
	}
}

// RemovedBooklist returns the removed ids of booklist.
func (m *BookMutation) RemovedBooklistIDs() (ids []int) {
	for id := range m.removedbooklist {
		ids = append(ids, id)
	}
	return
}

// BooklistIDs returns the booklist ids in the mutation.
func (m *BookMutation) BooklistIDs() (ids []int) {
	for id := range m.booklist {
		ids = append(ids, id)
	}
	return
}

// ResetBooklist reset all changes of the "booklist" edge.
func (m *BookMutation) ResetBooklist() {
	m.booklist = nil
	m.removedbooklist = nil
}

// Op returns the operation name.
func (m *BookMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Book).
func (m *BookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BookMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._BookName != nil {
		fields = append(fields, book.FieldBookName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case book.FieldBookName:
		return m.BookName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case book.FieldBookName:
		return m.OldBookName(ctx)
	}
	return nil, fmt.Errorf("unknown Book field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case book.FieldBookName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookName(v)
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BookMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BookMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Book numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BookMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Book nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BookMutation) ResetField(name string) error {
	switch name {
	case book.FieldBookName:
		m.ResetBookName()
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BookMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.category != nil {
		edges = append(edges, book.EdgeCategory)
	}
	if m.author != nil {
		edges = append(edges, book.EdgeAuthor)
	}
	if m.user != nil {
		edges = append(edges, book.EdgeUser)
	}
	if m.status != nil {
		edges = append(edges, book.EdgeStatus)
	}
	if m.booklist != nil {
		edges = append(edges, book.EdgeBooklist)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case book.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeStatus:
		if id := m.status; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeBooklist:
		ids := make([]ent.Value, 0, len(m.booklist))
		for id := range m.booklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedbooklist != nil {
		edges = append(edges, book.EdgeBooklist)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case book.EdgeBooklist:
		ids := make([]ent.Value, 0, len(m.removedbooklist))
		for id := range m.removedbooklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcategory {
		edges = append(edges, book.EdgeCategory)
	}
	if m.clearedauthor {
		edges = append(edges, book.EdgeAuthor)
	}
	if m.cleareduser {
		edges = append(edges, book.EdgeUser)
	}
	if m.clearedstatus {
		edges = append(edges, book.EdgeStatus)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BookMutation) EdgeCleared(name string) bool {
	switch name {
	case book.EdgeCategory:
		return m.clearedcategory
	case book.EdgeAuthor:
		return m.clearedauthor
	case book.EdgeUser:
		return m.cleareduser
	case book.EdgeStatus:
		return m.clearedstatus
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BookMutation) ClearEdge(name string) error {
	switch name {
	case book.EdgeCategory:
		m.ClearCategory()
		return nil
	case book.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case book.EdgeUser:
		m.ClearUser()
		return nil
	case book.EdgeStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Book unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BookMutation) ResetEdge(name string) error {
	switch name {
	case book.EdgeCategory:
		m.ResetCategory()
		return nil
	case book.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case book.EdgeUser:
		m.ResetUser()
		return nil
	case book.EdgeStatus:
		m.ResetStatus()
		return nil
	case book.EdgeBooklist:
		m.ResetBooklist()
		return nil
	}
	return fmt.Errorf("unknown Book edge %s", name)
}

// BookborrowMutation represents an operation that mutate the Bookborrows
// nodes in the graph.
type BookborrowMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_BORROW_DATE         *time.Time
	_RETURN_DATE         *time.Time
	clearedFields        map[string]struct{}
	_USER                *int
	cleared_USER         bool
	_BOOK                *int
	cleared_BOOK         bool
	_SERVICEPOINT        *int
	cleared_SERVICEPOINT bool
	borrowed             map[int]struct{}
	removedborrowed      map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Bookborrow, error)
}

var _ ent.Mutation = (*BookborrowMutation)(nil)

// bookborrowOption allows to manage the mutation configuration using functional options.
type bookborrowOption func(*BookborrowMutation)

// newBookborrowMutation creates new mutation for $n.Name.
func newBookborrowMutation(c config, op Op, opts ...bookborrowOption) *BookborrowMutation {
	m := &BookborrowMutation{
		config:        c,
		op:            op,
		typ:           TypeBookborrow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookborrowID sets the id field of the mutation.
func withBookborrowID(id int) bookborrowOption {
	return func(m *BookborrowMutation) {
		var (
			err   error
			once  sync.Once
			value *Bookborrow
		)
		m.oldValue = func(ctx context.Context) (*Bookborrow, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bookborrow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookborrow sets the old Bookborrow of the mutation.
func withBookborrow(node *Bookborrow) bookborrowOption {
	return func(m *BookborrowMutation) {
		m.oldValue = func(context.Context) (*Bookborrow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookborrowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookborrowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BookborrowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBORROWDATE sets the BORROW_DATE field.
func (m *BookborrowMutation) SetBORROWDATE(t time.Time) {
	m._BORROW_DATE = &t
}

// BORROWDATE returns the BORROW_DATE value in the mutation.
func (m *BookborrowMutation) BORROWDATE() (r time.Time, exists bool) {
	v := m._BORROW_DATE
	if v == nil {
		return
	}
	return *v, true
}

// OldBORROWDATE returns the old BORROW_DATE value of the Bookborrow.
// If the Bookborrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookborrowMutation) OldBORROWDATE(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBORROWDATE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBORROWDATE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBORROWDATE: %w", err)
	}
	return oldValue.BORROWDATE, nil
}

// ResetBORROWDATE reset all changes of the "BORROW_DATE" field.
func (m *BookborrowMutation) ResetBORROWDATE() {
	m._BORROW_DATE = nil
}

// SetRETURNDATE sets the RETURN_DATE field.
func (m *BookborrowMutation) SetRETURNDATE(t time.Time) {
	m._RETURN_DATE = &t
}

// RETURNDATE returns the RETURN_DATE value in the mutation.
func (m *BookborrowMutation) RETURNDATE() (r time.Time, exists bool) {
	v := m._RETURN_DATE
	if v == nil {
		return
	}
	return *v, true
}

// OldRETURNDATE returns the old RETURN_DATE value of the Bookborrow.
// If the Bookborrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookborrowMutation) OldRETURNDATE(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRETURNDATE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRETURNDATE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRETURNDATE: %w", err)
	}
	return oldValue.RETURNDATE, nil
}

// ResetRETURNDATE reset all changes of the "RETURN_DATE" field.
func (m *BookborrowMutation) ResetRETURNDATE() {
	m._RETURN_DATE = nil
}

// SetUSERID sets the USER edge to User by id.
func (m *BookborrowMutation) SetUSERID(id int) {
	m._USER = &id
}

// ClearUSER clears the USER edge to User.
func (m *BookborrowMutation) ClearUSER() {
	m.cleared_USER = true
}

// USERCleared returns if the edge USER was cleared.
func (m *BookborrowMutation) USERCleared() bool {
	return m.cleared_USER
}

// USERID returns the USER id in the mutation.
func (m *BookborrowMutation) USERID() (id int, exists bool) {
	if m._USER != nil {
		return *m._USER, true
	}
	return
}

// USERIDs returns the USER ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// USERID instead. It exists only for internal usage by the builders.
func (m *BookborrowMutation) USERIDs() (ids []int) {
	if id := m._USER; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUSER reset all changes of the "USER" edge.
func (m *BookborrowMutation) ResetUSER() {
	m._USER = nil
	m.cleared_USER = false
}

// SetBOOKID sets the BOOK edge to Book by id.
func (m *BookborrowMutation) SetBOOKID(id int) {
	m._BOOK = &id
}

// ClearBOOK clears the BOOK edge to Book.
func (m *BookborrowMutation) ClearBOOK() {
	m.cleared_BOOK = true
}

// BOOKCleared returns if the edge BOOK was cleared.
func (m *BookborrowMutation) BOOKCleared() bool {
	return m.cleared_BOOK
}

// BOOKID returns the BOOK id in the mutation.
func (m *BookborrowMutation) BOOKID() (id int, exists bool) {
	if m._BOOK != nil {
		return *m._BOOK, true
	}
	return
}

// BOOKIDs returns the BOOK ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BOOKID instead. It exists only for internal usage by the builders.
func (m *BookborrowMutation) BOOKIDs() (ids []int) {
	if id := m._BOOK; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBOOK reset all changes of the "BOOK" edge.
func (m *BookborrowMutation) ResetBOOK() {
	m._BOOK = nil
	m.cleared_BOOK = false
}

// SetSERVICEPOINTID sets the SERVICEPOINT edge to ServicePoint by id.
func (m *BookborrowMutation) SetSERVICEPOINTID(id int) {
	m._SERVICEPOINT = &id
}

// ClearSERVICEPOINT clears the SERVICEPOINT edge to ServicePoint.
func (m *BookborrowMutation) ClearSERVICEPOINT() {
	m.cleared_SERVICEPOINT = true
}

// SERVICEPOINTCleared returns if the edge SERVICEPOINT was cleared.
func (m *BookborrowMutation) SERVICEPOINTCleared() bool {
	return m.cleared_SERVICEPOINT
}

// SERVICEPOINTID returns the SERVICEPOINT id in the mutation.
func (m *BookborrowMutation) SERVICEPOINTID() (id int, exists bool) {
	if m._SERVICEPOINT != nil {
		return *m._SERVICEPOINT, true
	}
	return
}

// SERVICEPOINTIDs returns the SERVICEPOINT ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SERVICEPOINTID instead. It exists only for internal usage by the builders.
func (m *BookborrowMutation) SERVICEPOINTIDs() (ids []int) {
	if id := m._SERVICEPOINT; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSERVICEPOINT reset all changes of the "SERVICEPOINT" edge.
func (m *BookborrowMutation) ResetSERVICEPOINT() {
	m._SERVICEPOINT = nil
	m.cleared_SERVICEPOINT = false
}

// AddBorrowedIDs adds the borrowed edge to Bookreturn by ids.
func (m *BookborrowMutation) AddBorrowedIDs(ids ...int) {
	if m.borrowed == nil {
		m.borrowed = make(map[int]struct{})
	}
	for i := range ids {
		m.borrowed[ids[i]] = struct{}{}
	}
}

// RemoveBorrowedIDs removes the borrowed edge to Bookreturn by ids.
func (m *BookborrowMutation) RemoveBorrowedIDs(ids ...int) {
	if m.removedborrowed == nil {
		m.removedborrowed = make(map[int]struct{})
	}
	for i := range ids {
		m.removedborrowed[ids[i]] = struct{}{}
	}
}

// RemovedBorrowed returns the removed ids of borrowed.
func (m *BookborrowMutation) RemovedBorrowedIDs() (ids []int) {
	for id := range m.removedborrowed {
		ids = append(ids, id)
	}
	return
}

// BorrowedIDs returns the borrowed ids in the mutation.
func (m *BookborrowMutation) BorrowedIDs() (ids []int) {
	for id := range m.borrowed {
		ids = append(ids, id)
	}
	return
}

// ResetBorrowed reset all changes of the "borrowed" edge.
func (m *BookborrowMutation) ResetBorrowed() {
	m.borrowed = nil
	m.removedborrowed = nil
}

// Op returns the operation name.
func (m *BookborrowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bookborrow).
func (m *BookborrowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BookborrowMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._BORROW_DATE != nil {
		fields = append(fields, bookborrow.FieldBORROWDATE)
	}
	if m._RETURN_DATE != nil {
		fields = append(fields, bookborrow.FieldRETURNDATE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BookborrowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookborrow.FieldBORROWDATE:
		return m.BORROWDATE()
	case bookborrow.FieldRETURNDATE:
		return m.RETURNDATE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BookborrowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookborrow.FieldBORROWDATE:
		return m.OldBORROWDATE(ctx)
	case bookborrow.FieldRETURNDATE:
		return m.OldRETURNDATE(ctx)
	}
	return nil, fmt.Errorf("unknown Bookborrow field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookborrowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookborrow.FieldBORROWDATE:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBORROWDATE(v)
		return nil
	case bookborrow.FieldRETURNDATE:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRETURNDATE(v)
		return nil
	}
	return fmt.Errorf("unknown Bookborrow field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BookborrowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BookborrowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookborrowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bookborrow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BookborrowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BookborrowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookborrowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bookborrow nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BookborrowMutation) ResetField(name string) error {
	switch name {
	case bookborrow.FieldBORROWDATE:
		m.ResetBORROWDATE()
		return nil
	case bookborrow.FieldRETURNDATE:
		m.ResetRETURNDATE()
		return nil
	}
	return fmt.Errorf("unknown Bookborrow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BookborrowMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._USER != nil {
		edges = append(edges, bookborrow.EdgeUSER)
	}
	if m._BOOK != nil {
		edges = append(edges, bookborrow.EdgeBOOK)
	}
	if m._SERVICEPOINT != nil {
		edges = append(edges, bookborrow.EdgeSERVICEPOINT)
	}
	if m.borrowed != nil {
		edges = append(edges, bookborrow.EdgeBorrowed)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BookborrowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookborrow.EdgeUSER:
		if id := m._USER; id != nil {
			return []ent.Value{*id}
		}
	case bookborrow.EdgeBOOK:
		if id := m._BOOK; id != nil {
			return []ent.Value{*id}
		}
	case bookborrow.EdgeSERVICEPOINT:
		if id := m._SERVICEPOINT; id != nil {
			return []ent.Value{*id}
		}
	case bookborrow.EdgeBorrowed:
		ids := make([]ent.Value, 0, len(m.borrowed))
		for id := range m.borrowed {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BookborrowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedborrowed != nil {
		edges = append(edges, bookborrow.EdgeBorrowed)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BookborrowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bookborrow.EdgeBorrowed:
		ids := make([]ent.Value, 0, len(m.removedborrowed))
		for id := range m.removedborrowed {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BookborrowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_USER {
		edges = append(edges, bookborrow.EdgeUSER)
	}
	if m.cleared_BOOK {
		edges = append(edges, bookborrow.EdgeBOOK)
	}
	if m.cleared_SERVICEPOINT {
		edges = append(edges, bookborrow.EdgeSERVICEPOINT)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BookborrowMutation) EdgeCleared(name string) bool {
	switch name {
	case bookborrow.EdgeUSER:
		return m.cleared_USER
	case bookborrow.EdgeBOOK:
		return m.cleared_BOOK
	case bookborrow.EdgeSERVICEPOINT:
		return m.cleared_SERVICEPOINT
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BookborrowMutation) ClearEdge(name string) error {
	switch name {
	case bookborrow.EdgeUSER:
		m.ClearUSER()
		return nil
	case bookborrow.EdgeBOOK:
		m.ClearBOOK()
		return nil
	case bookborrow.EdgeSERVICEPOINT:
		m.ClearSERVICEPOINT()
		return nil
	}
	return fmt.Errorf("unknown Bookborrow unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BookborrowMutation) ResetEdge(name string) error {
	switch name {
	case bookborrow.EdgeUSER:
		m.ResetUSER()
		return nil
	case bookborrow.EdgeBOOK:
		m.ResetBOOK()
		return nil
	case bookborrow.EdgeSERVICEPOINT:
		m.ResetSERVICEPOINT()
		return nil
	case bookborrow.EdgeBorrowed:
		m.ResetBorrowed()
		return nil
	}
	return fmt.Errorf("unknown Bookborrow edge %s", name)
}

// BookingMutation represents an operation that mutate the Bookings
// nodes in the graph.
type BookingMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_BOOKING_DATE     *time.Time
	_TIME_LEFT        *time.Time
	_USER_NUMBER      *int
	add_USER_NUMBER   *int
	_BORROW_ITEM      *int
	add_BORROW_ITEM   *int
	_PHONE_NUMBER     *string
	clearedFields     map[string]struct{}
	usedby            *int
	clearedusedby     bool
	getservice        *int
	clearedgetservice bool
	using             *int
	clearedusing      bool
	done              bool
	oldValue          func(context.Context) (*Booking, error)
}

var _ ent.Mutation = (*BookingMutation)(nil)

// bookingOption allows to manage the mutation configuration using functional options.
type bookingOption func(*BookingMutation)

// newBookingMutation creates new mutation for $n.Name.
func newBookingMutation(c config, op Op, opts ...bookingOption) *BookingMutation {
	m := &BookingMutation{
		config:        c,
		op:            op,
		typ:           TypeBooking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingID sets the id field of the mutation.
func withBookingID(id int) bookingOption {
	return func(m *BookingMutation) {
		var (
			err   error
			once  sync.Once
			value *Booking
		)
		m.oldValue = func(ctx context.Context) (*Booking, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Booking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooking sets the old Booking of the mutation.
func withBooking(node *Booking) bookingOption {
	return func(m *BookingMutation) {
		m.oldValue = func(context.Context) (*Booking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BookingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBOOKINGDATE sets the BOOKING_DATE field.
func (m *BookingMutation) SetBOOKINGDATE(t time.Time) {
	m._BOOKING_DATE = &t
}

// BOOKINGDATE returns the BOOKING_DATE value in the mutation.
func (m *BookingMutation) BOOKINGDATE() (r time.Time, exists bool) {
	v := m._BOOKING_DATE
	if v == nil {
		return
	}
	return *v, true
}

// OldBOOKINGDATE returns the old BOOKING_DATE value of the Booking.
// If the Booking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookingMutation) OldBOOKINGDATE(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBOOKINGDATE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBOOKINGDATE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBOOKINGDATE: %w", err)
	}
	return oldValue.BOOKINGDATE, nil
}

// ResetBOOKINGDATE reset all changes of the "BOOKING_DATE" field.
func (m *BookingMutation) ResetBOOKINGDATE() {
	m._BOOKING_DATE = nil
}

// SetTIMELEFT sets the TIME_LEFT field.
func (m *BookingMutation) SetTIMELEFT(t time.Time) {
	m._TIME_LEFT = &t
}

// TIMELEFT returns the TIME_LEFT value in the mutation.
func (m *BookingMutation) TIMELEFT() (r time.Time, exists bool) {
	v := m._TIME_LEFT
	if v == nil {
		return
	}
	return *v, true
}

// OldTIMELEFT returns the old TIME_LEFT value of the Booking.
// If the Booking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookingMutation) OldTIMELEFT(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTIMELEFT is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTIMELEFT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTIMELEFT: %w", err)
	}
	return oldValue.TIMELEFT, nil
}

// ResetTIMELEFT reset all changes of the "TIME_LEFT" field.
func (m *BookingMutation) ResetTIMELEFT() {
	m._TIME_LEFT = nil
}

// SetUSERNUMBER sets the USER_NUMBER field.
func (m *BookingMutation) SetUSERNUMBER(i int) {
	m._USER_NUMBER = &i
	m.add_USER_NUMBER = nil
}

// USERNUMBER returns the USER_NUMBER value in the mutation.
func (m *BookingMutation) USERNUMBER() (r int, exists bool) {
	v := m._USER_NUMBER
	if v == nil {
		return
	}
	return *v, true
}

// OldUSERNUMBER returns the old USER_NUMBER value of the Booking.
// If the Booking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookingMutation) OldUSERNUMBER(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUSERNUMBER is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUSERNUMBER requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUSERNUMBER: %w", err)
	}
	return oldValue.USERNUMBER, nil
}

// AddUSERNUMBER adds i to USER_NUMBER.
func (m *BookingMutation) AddUSERNUMBER(i int) {
	if m.add_USER_NUMBER != nil {
		*m.add_USER_NUMBER += i
	} else {
		m.add_USER_NUMBER = &i
	}
}

// AddedUSERNUMBER returns the value that was added to the USER_NUMBER field in this mutation.
func (m *BookingMutation) AddedUSERNUMBER() (r int, exists bool) {
	v := m.add_USER_NUMBER
	if v == nil {
		return
	}
	return *v, true
}

// ResetUSERNUMBER reset all changes of the "USER_NUMBER" field.
func (m *BookingMutation) ResetUSERNUMBER() {
	m._USER_NUMBER = nil
	m.add_USER_NUMBER = nil
}

// SetBORROWITEM sets the BORROW_ITEM field.
func (m *BookingMutation) SetBORROWITEM(i int) {
	m._BORROW_ITEM = &i
	m.add_BORROW_ITEM = nil
}

// BORROWITEM returns the BORROW_ITEM value in the mutation.
func (m *BookingMutation) BORROWITEM() (r int, exists bool) {
	v := m._BORROW_ITEM
	if v == nil {
		return
	}
	return *v, true
}

// OldBORROWITEM returns the old BORROW_ITEM value of the Booking.
// If the Booking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookingMutation) OldBORROWITEM(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBORROWITEM is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBORROWITEM requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBORROWITEM: %w", err)
	}
	return oldValue.BORROWITEM, nil
}

// AddBORROWITEM adds i to BORROW_ITEM.
func (m *BookingMutation) AddBORROWITEM(i int) {
	if m.add_BORROW_ITEM != nil {
		*m.add_BORROW_ITEM += i
	} else {
		m.add_BORROW_ITEM = &i
	}
}

// AddedBORROWITEM returns the value that was added to the BORROW_ITEM field in this mutation.
func (m *BookingMutation) AddedBORROWITEM() (r int, exists bool) {
	v := m.add_BORROW_ITEM
	if v == nil {
		return
	}
	return *v, true
}

// ResetBORROWITEM reset all changes of the "BORROW_ITEM" field.
func (m *BookingMutation) ResetBORROWITEM() {
	m._BORROW_ITEM = nil
	m.add_BORROW_ITEM = nil
}

// SetPHONENUMBER sets the PHONE_NUMBER field.
func (m *BookingMutation) SetPHONENUMBER(s string) {
	m._PHONE_NUMBER = &s
}

// PHONENUMBER returns the PHONE_NUMBER value in the mutation.
func (m *BookingMutation) PHONENUMBER() (r string, exists bool) {
	v := m._PHONE_NUMBER
	if v == nil {
		return
	}
	return *v, true
}

// OldPHONENUMBER returns the old PHONE_NUMBER value of the Booking.
// If the Booking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookingMutation) OldPHONENUMBER(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPHONENUMBER is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPHONENUMBER requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHONENUMBER: %w", err)
	}
	return oldValue.PHONENUMBER, nil
}

// ResetPHONENUMBER reset all changes of the "PHONE_NUMBER" field.
func (m *BookingMutation) ResetPHONENUMBER() {
	m._PHONE_NUMBER = nil
}

// SetUsedbyID sets the usedby edge to User by id.
func (m *BookingMutation) SetUsedbyID(id int) {
	m.usedby = &id
}

// ClearUsedby clears the usedby edge to User.
func (m *BookingMutation) ClearUsedby() {
	m.clearedusedby = true
}

// UsedbyCleared returns if the edge usedby was cleared.
func (m *BookingMutation) UsedbyCleared() bool {
	return m.clearedusedby
}

// UsedbyID returns the usedby id in the mutation.
func (m *BookingMutation) UsedbyID() (id int, exists bool) {
	if m.usedby != nil {
		return *m.usedby, true
	}
	return
}

// UsedbyIDs returns the usedby ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UsedbyID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) UsedbyIDs() (ids []int) {
	if id := m.usedby; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsedby reset all changes of the "usedby" edge.
func (m *BookingMutation) ResetUsedby() {
	m.usedby = nil
	m.clearedusedby = false
}

// SetGetserviceID sets the getservice edge to ServicePoint by id.
func (m *BookingMutation) SetGetserviceID(id int) {
	m.getservice = &id
}

// ClearGetservice clears the getservice edge to ServicePoint.
func (m *BookingMutation) ClearGetservice() {
	m.clearedgetservice = true
}

// GetserviceCleared returns if the edge getservice was cleared.
func (m *BookingMutation) GetserviceCleared() bool {
	return m.clearedgetservice
}

// GetserviceID returns the getservice id in the mutation.
func (m *BookingMutation) GetserviceID() (id int, exists bool) {
	if m.getservice != nil {
		return *m.getservice, true
	}
	return
}

// GetserviceIDs returns the getservice ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// GetserviceID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) GetserviceIDs() (ids []int) {
	if id := m.getservice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGetservice reset all changes of the "getservice" edge.
func (m *BookingMutation) ResetGetservice() {
	m.getservice = nil
	m.clearedgetservice = false
}

// SetUsingID sets the using edge to ClientEntity by id.
func (m *BookingMutation) SetUsingID(id int) {
	m.using = &id
}

// ClearUsing clears the using edge to ClientEntity.
func (m *BookingMutation) ClearUsing() {
	m.clearedusing = true
}

// UsingCleared returns if the edge using was cleared.
func (m *BookingMutation) UsingCleared() bool {
	return m.clearedusing
}

// UsingID returns the using id in the mutation.
func (m *BookingMutation) UsingID() (id int, exists bool) {
	if m.using != nil {
		return *m.using, true
	}
	return
}

// UsingIDs returns the using ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UsingID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) UsingIDs() (ids []int) {
	if id := m.using; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsing reset all changes of the "using" edge.
func (m *BookingMutation) ResetUsing() {
	m.using = nil
	m.clearedusing = false
}

// Op returns the operation name.
func (m *BookingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Booking).
func (m *BookingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BookingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._BOOKING_DATE != nil {
		fields = append(fields, booking.FieldBOOKINGDATE)
	}
	if m._TIME_LEFT != nil {
		fields = append(fields, booking.FieldTIMELEFT)
	}
	if m._USER_NUMBER != nil {
		fields = append(fields, booking.FieldUSERNUMBER)
	}
	if m._BORROW_ITEM != nil {
		fields = append(fields, booking.FieldBORROWITEM)
	}
	if m._PHONE_NUMBER != nil {
		fields = append(fields, booking.FieldPHONENUMBER)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BookingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldBOOKINGDATE:
		return m.BOOKINGDATE()
	case booking.FieldTIMELEFT:
		return m.TIMELEFT()
	case booking.FieldUSERNUMBER:
		return m.USERNUMBER()
	case booking.FieldBORROWITEM:
		return m.BORROWITEM()
	case booking.FieldPHONENUMBER:
		return m.PHONENUMBER()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BookingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case booking.FieldBOOKINGDATE:
		return m.OldBOOKINGDATE(ctx)
	case booking.FieldTIMELEFT:
		return m.OldTIMELEFT(ctx)
	case booking.FieldUSERNUMBER:
		return m.OldUSERNUMBER(ctx)
	case booking.FieldBORROWITEM:
		return m.OldBORROWITEM(ctx)
	case booking.FieldPHONENUMBER:
		return m.OldPHONENUMBER(ctx)
	}
	return nil, fmt.Errorf("unknown Booking field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case booking.FieldBOOKINGDATE:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBOOKINGDATE(v)
		return nil
	case booking.FieldTIMELEFT:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTIMELEFT(v)
		return nil
	case booking.FieldUSERNUMBER:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUSERNUMBER(v)
		return nil
	case booking.FieldBORROWITEM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBORROWITEM(v)
		return nil
	case booking.FieldPHONENUMBER:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHONENUMBER(v)
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BookingMutation) AddedFields() []string {
	var fields []string
	if m.add_USER_NUMBER != nil {
		fields = append(fields, booking.FieldUSERNUMBER)
	}
	if m.add_BORROW_ITEM != nil {
		fields = append(fields, booking.FieldBORROWITEM)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BookingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldUSERNUMBER:
		return m.AddedUSERNUMBER()
	case booking.FieldBORROWITEM:
		return m.AddedBORROWITEM()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case booking.FieldUSERNUMBER:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUSERNUMBER(v)
		return nil
	case booking.FieldBORROWITEM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBORROWITEM(v)
		return nil
	}
	return fmt.Errorf("unknown Booking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BookingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BookingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Booking nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BookingMutation) ResetField(name string) error {
	switch name {
	case booking.FieldBOOKINGDATE:
		m.ResetBOOKINGDATE()
		return nil
	case booking.FieldTIMELEFT:
		m.ResetTIMELEFT()
		return nil
	case booking.FieldUSERNUMBER:
		m.ResetUSERNUMBER()
		return nil
	case booking.FieldBORROWITEM:
		m.ResetBORROWITEM()
		return nil
	case booking.FieldPHONENUMBER:
		m.ResetPHONENUMBER()
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BookingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.usedby != nil {
		edges = append(edges, booking.EdgeUsedby)
	}
	if m.getservice != nil {
		edges = append(edges, booking.EdgeGetservice)
	}
	if m.using != nil {
		edges = append(edges, booking.EdgeUsing)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BookingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgeUsedby:
		if id := m.usedby; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeGetservice:
		if id := m.getservice; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeUsing:
		if id := m.using; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BookingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BookingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BookingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedusedby {
		edges = append(edges, booking.EdgeUsedby)
	}
	if m.clearedgetservice {
		edges = append(edges, booking.EdgeGetservice)
	}
	if m.clearedusing {
		edges = append(edges, booking.EdgeUsing)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BookingMutation) EdgeCleared(name string) bool {
	switch name {
	case booking.EdgeUsedby:
		return m.clearedusedby
	case booking.EdgeGetservice:
		return m.clearedgetservice
	case booking.EdgeUsing:
		return m.clearedusing
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BookingMutation) ClearEdge(name string) error {
	switch name {
	case booking.EdgeUsedby:
		m.ClearUsedby()
		return nil
	case booking.EdgeGetservice:
		m.ClearGetservice()
		return nil
	case booking.EdgeUsing:
		m.ClearUsing()
		return nil
	}
	return fmt.Errorf("unknown Booking unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BookingMutation) ResetEdge(name string) error {
	switch name {
	case booking.EdgeUsedby:
		m.ResetUsedby()
		return nil
	case booking.EdgeGetservice:
		m.ResetGetservice()
		return nil
	case booking.EdgeUsing:
		m.ResetUsing()
		return nil
	}
	return fmt.Errorf("unknown Booking edge %s", name)
}

// BookreturnMutation represents an operation that mutate the Bookreturns
// nodes in the graph.
type BookreturnMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_RETURN_TIME       *time.Time
	_DAMAGED_POINT     *int
	add_DAMAGED_POINT  *int
	_DAMAGED_POINTNAME *string
	_LOST              *string
	clearedFields      map[string]struct{}
	user               *int
	cleareduser        bool
	location           *int
	clearedlocation    bool
	mustreturn         *int
	clearedmustreturn  bool
	done               bool
	oldValue           func(context.Context) (*Bookreturn, error)
}

var _ ent.Mutation = (*BookreturnMutation)(nil)

// bookreturnOption allows to manage the mutation configuration using functional options.
type bookreturnOption func(*BookreturnMutation)

// newBookreturnMutation creates new mutation for $n.Name.
func newBookreturnMutation(c config, op Op, opts ...bookreturnOption) *BookreturnMutation {
	m := &BookreturnMutation{
		config:        c,
		op:            op,
		typ:           TypeBookreturn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookreturnID sets the id field of the mutation.
func withBookreturnID(id int) bookreturnOption {
	return func(m *BookreturnMutation) {
		var (
			err   error
			once  sync.Once
			value *Bookreturn
		)
		m.oldValue = func(ctx context.Context) (*Bookreturn, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bookreturn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookreturn sets the old Bookreturn of the mutation.
func withBookreturn(node *Bookreturn) bookreturnOption {
	return func(m *BookreturnMutation) {
		m.oldValue = func(context.Context) (*Bookreturn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookreturnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookreturnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BookreturnMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRETURNTIME sets the RETURN_TIME field.
func (m *BookreturnMutation) SetRETURNTIME(t time.Time) {
	m._RETURN_TIME = &t
}

// RETURNTIME returns the RETURN_TIME value in the mutation.
func (m *BookreturnMutation) RETURNTIME() (r time.Time, exists bool) {
	v := m._RETURN_TIME
	if v == nil {
		return
	}
	return *v, true
}

// OldRETURNTIME returns the old RETURN_TIME value of the Bookreturn.
// If the Bookreturn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookreturnMutation) OldRETURNTIME(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRETURNTIME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRETURNTIME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRETURNTIME: %w", err)
	}
	return oldValue.RETURNTIME, nil
}

// ResetRETURNTIME reset all changes of the "RETURN_TIME" field.
func (m *BookreturnMutation) ResetRETURNTIME() {
	m._RETURN_TIME = nil
}

// SetDAMAGEDPOINT sets the DAMAGED_POINT field.
func (m *BookreturnMutation) SetDAMAGEDPOINT(i int) {
	m._DAMAGED_POINT = &i
	m.add_DAMAGED_POINT = nil
}

// DAMAGEDPOINT returns the DAMAGED_POINT value in the mutation.
func (m *BookreturnMutation) DAMAGEDPOINT() (r int, exists bool) {
	v := m._DAMAGED_POINT
	if v == nil {
		return
	}
	return *v, true
}

// OldDAMAGEDPOINT returns the old DAMAGED_POINT value of the Bookreturn.
// If the Bookreturn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookreturnMutation) OldDAMAGEDPOINT(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDAMAGEDPOINT is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDAMAGEDPOINT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDAMAGEDPOINT: %w", err)
	}
	return oldValue.DAMAGEDPOINT, nil
}

// AddDAMAGEDPOINT adds i to DAMAGED_POINT.
func (m *BookreturnMutation) AddDAMAGEDPOINT(i int) {
	if m.add_DAMAGED_POINT != nil {
		*m.add_DAMAGED_POINT += i
	} else {
		m.add_DAMAGED_POINT = &i
	}
}

// AddedDAMAGEDPOINT returns the value that was added to the DAMAGED_POINT field in this mutation.
func (m *BookreturnMutation) AddedDAMAGEDPOINT() (r int, exists bool) {
	v := m.add_DAMAGED_POINT
	if v == nil {
		return
	}
	return *v, true
}

// ResetDAMAGEDPOINT reset all changes of the "DAMAGED_POINT" field.
func (m *BookreturnMutation) ResetDAMAGEDPOINT() {
	m._DAMAGED_POINT = nil
	m.add_DAMAGED_POINT = nil
}

// SetDAMAGEDPOINTNAME sets the DAMAGED_POINTNAME field.
func (m *BookreturnMutation) SetDAMAGEDPOINTNAME(s string) {
	m._DAMAGED_POINTNAME = &s
}

// DAMAGEDPOINTNAME returns the DAMAGED_POINTNAME value in the mutation.
func (m *BookreturnMutation) DAMAGEDPOINTNAME() (r string, exists bool) {
	v := m._DAMAGED_POINTNAME
	if v == nil {
		return
	}
	return *v, true
}

// OldDAMAGEDPOINTNAME returns the old DAMAGED_POINTNAME value of the Bookreturn.
// If the Bookreturn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookreturnMutation) OldDAMAGEDPOINTNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDAMAGEDPOINTNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDAMAGEDPOINTNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDAMAGEDPOINTNAME: %w", err)
	}
	return oldValue.DAMAGEDPOINTNAME, nil
}

// ResetDAMAGEDPOINTNAME reset all changes of the "DAMAGED_POINTNAME" field.
func (m *BookreturnMutation) ResetDAMAGEDPOINTNAME() {
	m._DAMAGED_POINTNAME = nil
}

// SetLOST sets the LOST field.
func (m *BookreturnMutation) SetLOST(s string) {
	m._LOST = &s
}

// LOST returns the LOST value in the mutation.
func (m *BookreturnMutation) LOST() (r string, exists bool) {
	v := m._LOST
	if v == nil {
		return
	}
	return *v, true
}

// OldLOST returns the old LOST value of the Bookreturn.
// If the Bookreturn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookreturnMutation) OldLOST(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLOST is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLOST requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLOST: %w", err)
	}
	return oldValue.LOST, nil
}

// ResetLOST reset all changes of the "LOST" field.
func (m *BookreturnMutation) ResetLOST() {
	m._LOST = nil
}

// SetUserID sets the user edge to User by id.
func (m *BookreturnMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *BookreturnMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *BookreturnMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *BookreturnMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BookreturnMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *BookreturnMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetLocationID sets the location edge to Location by id.
func (m *BookreturnMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the location edge to Location.
func (m *BookreturnMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared returns if the edge location was cleared.
func (m *BookreturnMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the location id in the mutation.
func (m *BookreturnMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the location ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *BookreturnMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation reset all changes of the "location" edge.
func (m *BookreturnMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetMustreturnID sets the mustreturn edge to Bookborrow by id.
func (m *BookreturnMutation) SetMustreturnID(id int) {
	m.mustreturn = &id
}

// ClearMustreturn clears the mustreturn edge to Bookborrow.
func (m *BookreturnMutation) ClearMustreturn() {
	m.clearedmustreturn = true
}

// MustreturnCleared returns if the edge mustreturn was cleared.
func (m *BookreturnMutation) MustreturnCleared() bool {
	return m.clearedmustreturn
}

// MustreturnID returns the mustreturn id in the mutation.
func (m *BookreturnMutation) MustreturnID() (id int, exists bool) {
	if m.mustreturn != nil {
		return *m.mustreturn, true
	}
	return
}

// MustreturnIDs returns the mustreturn ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MustreturnID instead. It exists only for internal usage by the builders.
func (m *BookreturnMutation) MustreturnIDs() (ids []int) {
	if id := m.mustreturn; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMustreturn reset all changes of the "mustreturn" edge.
func (m *BookreturnMutation) ResetMustreturn() {
	m.mustreturn = nil
	m.clearedmustreturn = false
}

// Op returns the operation name.
func (m *BookreturnMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bookreturn).
func (m *BookreturnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BookreturnMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._RETURN_TIME != nil {
		fields = append(fields, bookreturn.FieldRETURNTIME)
	}
	if m._DAMAGED_POINT != nil {
		fields = append(fields, bookreturn.FieldDAMAGEDPOINT)
	}
	if m._DAMAGED_POINTNAME != nil {
		fields = append(fields, bookreturn.FieldDAMAGEDPOINTNAME)
	}
	if m._LOST != nil {
		fields = append(fields, bookreturn.FieldLOST)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BookreturnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookreturn.FieldRETURNTIME:
		return m.RETURNTIME()
	case bookreturn.FieldDAMAGEDPOINT:
		return m.DAMAGEDPOINT()
	case bookreturn.FieldDAMAGEDPOINTNAME:
		return m.DAMAGEDPOINTNAME()
	case bookreturn.FieldLOST:
		return m.LOST()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BookreturnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookreturn.FieldRETURNTIME:
		return m.OldRETURNTIME(ctx)
	case bookreturn.FieldDAMAGEDPOINT:
		return m.OldDAMAGEDPOINT(ctx)
	case bookreturn.FieldDAMAGEDPOINTNAME:
		return m.OldDAMAGEDPOINTNAME(ctx)
	case bookreturn.FieldLOST:
		return m.OldLOST(ctx)
	}
	return nil, fmt.Errorf("unknown Bookreturn field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookreturnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookreturn.FieldRETURNTIME:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRETURNTIME(v)
		return nil
	case bookreturn.FieldDAMAGEDPOINT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDAMAGEDPOINT(v)
		return nil
	case bookreturn.FieldDAMAGEDPOINTNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDAMAGEDPOINTNAME(v)
		return nil
	case bookreturn.FieldLOST:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLOST(v)
		return nil
	}
	return fmt.Errorf("unknown Bookreturn field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BookreturnMutation) AddedFields() []string {
	var fields []string
	if m.add_DAMAGED_POINT != nil {
		fields = append(fields, bookreturn.FieldDAMAGEDPOINT)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BookreturnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bookreturn.FieldDAMAGEDPOINT:
		return m.AddedDAMAGEDPOINT()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookreturnMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bookreturn.FieldDAMAGEDPOINT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDAMAGEDPOINT(v)
		return nil
	}
	return fmt.Errorf("unknown Bookreturn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BookreturnMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BookreturnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookreturnMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bookreturn nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BookreturnMutation) ResetField(name string) error {
	switch name {
	case bookreturn.FieldRETURNTIME:
		m.ResetRETURNTIME()
		return nil
	case bookreturn.FieldDAMAGEDPOINT:
		m.ResetDAMAGEDPOINT()
		return nil
	case bookreturn.FieldDAMAGEDPOINTNAME:
		m.ResetDAMAGEDPOINTNAME()
		return nil
	case bookreturn.FieldLOST:
		m.ResetLOST()
		return nil
	}
	return fmt.Errorf("unknown Bookreturn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BookreturnMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, bookreturn.EdgeUser)
	}
	if m.location != nil {
		edges = append(edges, bookreturn.EdgeLocation)
	}
	if m.mustreturn != nil {
		edges = append(edges, bookreturn.EdgeMustreturn)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BookreturnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookreturn.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case bookreturn.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case bookreturn.EdgeMustreturn:
		if id := m.mustreturn; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BookreturnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BookreturnMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BookreturnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, bookreturn.EdgeUser)
	}
	if m.clearedlocation {
		edges = append(edges, bookreturn.EdgeLocation)
	}
	if m.clearedmustreturn {
		edges = append(edges, bookreturn.EdgeMustreturn)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BookreturnMutation) EdgeCleared(name string) bool {
	switch name {
	case bookreturn.EdgeUser:
		return m.cleareduser
	case bookreturn.EdgeLocation:
		return m.clearedlocation
	case bookreturn.EdgeMustreturn:
		return m.clearedmustreturn
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BookreturnMutation) ClearEdge(name string) error {
	switch name {
	case bookreturn.EdgeUser:
		m.ClearUser()
		return nil
	case bookreturn.EdgeLocation:
		m.ClearLocation()
		return nil
	case bookreturn.EdgeMustreturn:
		m.ClearMustreturn()
		return nil
	}
	return fmt.Errorf("unknown Bookreturn unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BookreturnMutation) ResetEdge(name string) error {
	switch name {
	case bookreturn.EdgeUser:
		m.ResetUser()
		return nil
	case bookreturn.EdgeLocation:
		m.ResetLocation()
		return nil
	case bookreturn.EdgeMustreturn:
		m.ResetMustreturn()
		return nil
	}
	return fmt.Errorf("unknown Bookreturn edge %s", name)
}

// CategoryMutation represents an operation that mutate the Categories
// nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_CategoryName *string
	clearedFields map[string]struct{}
	catof         map[int]struct{}
	removedcatof  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Category, error)
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows to manage the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for $n.Name.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the id field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCategoryName sets the CategoryName field.
func (m *CategoryMutation) SetCategoryName(s string) {
	m._CategoryName = &s
}

// CategoryName returns the CategoryName value in the mutation.
func (m *CategoryMutation) CategoryName() (r string, exists bool) {
	v := m._CategoryName
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryName returns the old CategoryName value of the Category.
// If the Category object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CategoryMutation) OldCategoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryName: %w", err)
	}
	return oldValue.CategoryName, nil
}

// ResetCategoryName reset all changes of the "CategoryName" field.
func (m *CategoryMutation) ResetCategoryName() {
	m._CategoryName = nil
}

// AddCatofIDs adds the catof edge to Book by ids.
func (m *CategoryMutation) AddCatofIDs(ids ...int) {
	if m.catof == nil {
		m.catof = make(map[int]struct{})
	}
	for i := range ids {
		m.catof[ids[i]] = struct{}{}
	}
}

// RemoveCatofIDs removes the catof edge to Book by ids.
func (m *CategoryMutation) RemoveCatofIDs(ids ...int) {
	if m.removedcatof == nil {
		m.removedcatof = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcatof[ids[i]] = struct{}{}
	}
}

// RemovedCatof returns the removed ids of catof.
func (m *CategoryMutation) RemovedCatofIDs() (ids []int) {
	for id := range m.removedcatof {
		ids = append(ids, id)
	}
	return
}

// CatofIDs returns the catof ids in the mutation.
func (m *CategoryMutation) CatofIDs() (ids []int) {
	for id := range m.catof {
		ids = append(ids, id)
	}
	return
}

// ResetCatof reset all changes of the "catof" edge.
func (m *CategoryMutation) ResetCatof() {
	m.catof = nil
	m.removedcatof = nil
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._CategoryName != nil {
		fields = append(fields, category.FieldCategoryName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCategoryName:
		return m.CategoryName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCategoryName:
		return m.OldCategoryName(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCategoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryName(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCategoryName:
		m.ResetCategoryName()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.catof != nil {
		edges = append(edges, category.EdgeCatof)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCatof:
		ids := make([]ent.Value, 0, len(m.catof))
		for id := range m.catof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcatof != nil {
		edges = append(edges, category.EdgeCatof)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCatof:
		ids := make([]ent.Value, 0, len(m.removedcatof))
		for id := range m.removedcatof {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeCatof:
		m.ResetCatof()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// ClientEntityMutation represents an operation that mutate the ClientEntities
// nodes in the graph.
type ClientEntityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_CLIENT_NAME  *string
	clearedFields map[string]struct{}
	booked        map[int]struct{}
	removedbooked map[int]struct{}
	state         *int
	clearedstate  bool
	done          bool
	oldValue      func(context.Context) (*ClientEntity, error)
}

var _ ent.Mutation = (*ClientEntityMutation)(nil)

// cliententityOption allows to manage the mutation configuration using functional options.
type cliententityOption func(*ClientEntityMutation)

// newClientEntityMutation creates new mutation for $n.Name.
func newClientEntityMutation(c config, op Op, opts ...cliententityOption) *ClientEntityMutation {
	m := &ClientEntityMutation{
		config:        c,
		op:            op,
		typ:           TypeClientEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClientEntityID sets the id field of the mutation.
func withClientEntityID(id int) cliententityOption {
	return func(m *ClientEntityMutation) {
		var (
			err   error
			once  sync.Once
			value *ClientEntity
		)
		m.oldValue = func(ctx context.Context) (*ClientEntity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClientEntity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClientEntity sets the old ClientEntity of the mutation.
func withClientEntity(node *ClientEntity) cliententityOption {
	return func(m *ClientEntityMutation) {
		m.oldValue = func(context.Context) (*ClientEntity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClientEntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClientEntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClientEntityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCLIENTNAME sets the CLIENT_NAME field.
func (m *ClientEntityMutation) SetCLIENTNAME(s string) {
	m._CLIENT_NAME = &s
}

// CLIENTNAME returns the CLIENT_NAME value in the mutation.
func (m *ClientEntityMutation) CLIENTNAME() (r string, exists bool) {
	v := m._CLIENT_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldCLIENTNAME returns the old CLIENT_NAME value of the ClientEntity.
// If the ClientEntity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClientEntityMutation) OldCLIENTNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCLIENTNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCLIENTNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCLIENTNAME: %w", err)
	}
	return oldValue.CLIENTNAME, nil
}

// ResetCLIENTNAME reset all changes of the "CLIENT_NAME" field.
func (m *ClientEntityMutation) ResetCLIENTNAME() {
	m._CLIENT_NAME = nil
}

// AddBookedIDs adds the booked edge to Booking by ids.
func (m *ClientEntityMutation) AddBookedIDs(ids ...int) {
	if m.booked == nil {
		m.booked = make(map[int]struct{})
	}
	for i := range ids {
		m.booked[ids[i]] = struct{}{}
	}
}

// RemoveBookedIDs removes the booked edge to Booking by ids.
func (m *ClientEntityMutation) RemoveBookedIDs(ids ...int) {
	if m.removedbooked == nil {
		m.removedbooked = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooked[ids[i]] = struct{}{}
	}
}

// RemovedBooked returns the removed ids of booked.
func (m *ClientEntityMutation) RemovedBookedIDs() (ids []int) {
	for id := range m.removedbooked {
		ids = append(ids, id)
	}
	return
}

// BookedIDs returns the booked ids in the mutation.
func (m *ClientEntityMutation) BookedIDs() (ids []int) {
	for id := range m.booked {
		ids = append(ids, id)
	}
	return
}

// ResetBooked reset all changes of the "booked" edge.
func (m *ClientEntityMutation) ResetBooked() {
	m.booked = nil
	m.removedbooked = nil
}

// SetStateID sets the state edge to Status by id.
func (m *ClientEntityMutation) SetStateID(id int) {
	m.state = &id
}

// ClearState clears the state edge to Status.
func (m *ClientEntityMutation) ClearState() {
	m.clearedstate = true
}

// StateCleared returns if the edge state was cleared.
func (m *ClientEntityMutation) StateCleared() bool {
	return m.clearedstate
}

// StateID returns the state id in the mutation.
func (m *ClientEntityMutation) StateID() (id int, exists bool) {
	if m.state != nil {
		return *m.state, true
	}
	return
}

// StateIDs returns the state ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *ClientEntityMutation) StateIDs() (ids []int) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState reset all changes of the "state" edge.
func (m *ClientEntityMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// Op returns the operation name.
func (m *ClientEntityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClientEntity).
func (m *ClientEntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClientEntityMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._CLIENT_NAME != nil {
		fields = append(fields, cliententity.FieldCLIENTNAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClientEntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cliententity.FieldCLIENTNAME:
		return m.CLIENTNAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClientEntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cliententity.FieldCLIENTNAME:
		return m.OldCLIENTNAME(ctx)
	}
	return nil, fmt.Errorf("unknown ClientEntity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClientEntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cliententity.FieldCLIENTNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCLIENTNAME(v)
		return nil
	}
	return fmt.Errorf("unknown ClientEntity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClientEntityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClientEntityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClientEntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClientEntity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClientEntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClientEntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClientEntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClientEntity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClientEntityMutation) ResetField(name string) error {
	switch name {
	case cliententity.FieldCLIENTNAME:
		m.ResetCLIENTNAME()
		return nil
	}
	return fmt.Errorf("unknown ClientEntity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClientEntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.booked != nil {
		edges = append(edges, cliententity.EdgeBooked)
	}
	if m.state != nil {
		edges = append(edges, cliententity.EdgeState)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClientEntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cliententity.EdgeBooked:
		ids := make([]ent.Value, 0, len(m.booked))
		for id := range m.booked {
			ids = append(ids, id)
		}
		return ids
	case cliententity.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClientEntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbooked != nil {
		edges = append(edges, cliententity.EdgeBooked)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClientEntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cliententity.EdgeBooked:
		ids := make([]ent.Value, 0, len(m.removedbooked))
		for id := range m.removedbooked {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClientEntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstate {
		edges = append(edges, cliententity.EdgeState)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClientEntityMutation) EdgeCleared(name string) bool {
	switch name {
	case cliententity.EdgeState:
		return m.clearedstate
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClientEntityMutation) ClearEdge(name string) error {
	switch name {
	case cliententity.EdgeState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown ClientEntity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClientEntityMutation) ResetEdge(name string) error {
	switch name {
	case cliententity.EdgeBooked:
		m.ResetBooked()
		return nil
	case cliententity.EdgeState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown ClientEntity edge %s", name)
}

// LocationMutation represents an operation that mutate the Locations
// nodes in the graph.
type LocationMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_LOCATION_NAME    *string
	clearedFields     map[string]struct{}
	returnfrom        map[int]struct{}
	removedreturnfrom map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Location, error)
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows to manage the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for $n.Name.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the id field of the mutation.
func withLocationID(id int) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLOCATIONNAME sets the LOCATION_NAME field.
func (m *LocationMutation) SetLOCATIONNAME(s string) {
	m._LOCATION_NAME = &s
}

// LOCATIONNAME returns the LOCATION_NAME value in the mutation.
func (m *LocationMutation) LOCATIONNAME() (r string, exists bool) {
	v := m._LOCATION_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldLOCATIONNAME returns the old LOCATION_NAME value of the Location.
// If the Location object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LocationMutation) OldLOCATIONNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLOCATIONNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLOCATIONNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLOCATIONNAME: %w", err)
	}
	return oldValue.LOCATIONNAME, nil
}

// ResetLOCATIONNAME reset all changes of the "LOCATION_NAME" field.
func (m *LocationMutation) ResetLOCATIONNAME() {
	m._LOCATION_NAME = nil
}

// AddReturnfromIDs adds the returnfrom edge to Bookreturn by ids.
func (m *LocationMutation) AddReturnfromIDs(ids ...int) {
	if m.returnfrom == nil {
		m.returnfrom = make(map[int]struct{})
	}
	for i := range ids {
		m.returnfrom[ids[i]] = struct{}{}
	}
}

// RemoveReturnfromIDs removes the returnfrom edge to Bookreturn by ids.
func (m *LocationMutation) RemoveReturnfromIDs(ids ...int) {
	if m.removedreturnfrom == nil {
		m.removedreturnfrom = make(map[int]struct{})
	}
	for i := range ids {
		m.removedreturnfrom[ids[i]] = struct{}{}
	}
}

// RemovedReturnfrom returns the removed ids of returnfrom.
func (m *LocationMutation) RemovedReturnfromIDs() (ids []int) {
	for id := range m.removedreturnfrom {
		ids = append(ids, id)
	}
	return
}

// ReturnfromIDs returns the returnfrom ids in the mutation.
func (m *LocationMutation) ReturnfromIDs() (ids []int) {
	for id := range m.returnfrom {
		ids = append(ids, id)
	}
	return
}

// ResetReturnfrom reset all changes of the "returnfrom" edge.
func (m *LocationMutation) ResetReturnfrom() {
	m.returnfrom = nil
	m.removedreturnfrom = nil
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._LOCATION_NAME != nil {
		fields = append(fields, location.FieldLOCATIONNAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldLOCATIONNAME:
		return m.LOCATIONNAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldLOCATIONNAME:
		return m.OldLOCATIONNAME(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldLOCATIONNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLOCATIONNAME(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LocationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldLOCATIONNAME:
		m.ResetLOCATIONNAME()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.returnfrom != nil {
		edges = append(edges, location.EdgeReturnfrom)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeReturnfrom:
		ids := make([]ent.Value, 0, len(m.returnfrom))
		for id := range m.returnfrom {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedreturnfrom != nil {
		edges = append(edges, location.EdgeReturnfrom)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeReturnfrom:
		ids := make([]ent.Value, 0, len(m.removedreturnfrom))
		for id := range m.removedreturnfrom {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeReturnfrom:
		m.ResetReturnfrom()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// PreemptionMutation represents an operation that mutate the Preemptions
// nodes in the graph.
type PreemptionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_PreemptTime      *time.Time
	clearedFields     map[string]struct{}
	_User_ID          *int
	cleared_User_ID   bool
	_PurposeID        *int
	cleared_PurposeID bool
	_RoomID           *int
	cleared_RoomID    bool
	done              bool
	oldValue          func(context.Context) (*Preemption, error)
}

var _ ent.Mutation = (*PreemptionMutation)(nil)

// preemptionOption allows to manage the mutation configuration using functional options.
type preemptionOption func(*PreemptionMutation)

// newPreemptionMutation creates new mutation for $n.Name.
func newPreemptionMutation(c config, op Op, opts ...preemptionOption) *PreemptionMutation {
	m := &PreemptionMutation{
		config:        c,
		op:            op,
		typ:           TypePreemption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPreemptionID sets the id field of the mutation.
func withPreemptionID(id int) preemptionOption {
	return func(m *PreemptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Preemption
		)
		m.oldValue = func(ctx context.Context) (*Preemption, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Preemption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPreemption sets the old Preemption of the mutation.
func withPreemption(node *Preemption) preemptionOption {
	return func(m *PreemptionMutation) {
		m.oldValue = func(context.Context) (*Preemption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PreemptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PreemptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PreemptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPreemptTime sets the PreemptTime field.
func (m *PreemptionMutation) SetPreemptTime(t time.Time) {
	m._PreemptTime = &t
}

// PreemptTime returns the PreemptTime value in the mutation.
func (m *PreemptionMutation) PreemptTime() (r time.Time, exists bool) {
	v := m._PreemptTime
	if v == nil {
		return
	}
	return *v, true
}

// OldPreemptTime returns the old PreemptTime value of the Preemption.
// If the Preemption object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PreemptionMutation) OldPreemptTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPreemptTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPreemptTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreemptTime: %w", err)
	}
	return oldValue.PreemptTime, nil
}

// ResetPreemptTime reset all changes of the "PreemptTime" field.
func (m *PreemptionMutation) ResetPreemptTime() {
	m._PreemptTime = nil
}

// SetUserIDID sets the User_ID edge to User by id.
func (m *PreemptionMutation) SetUserIDID(id int) {
	m._User_ID = &id
}

// ClearUserID clears the User_ID edge to User.
func (m *PreemptionMutation) ClearUserID() {
	m.cleared_User_ID = true
}

// UserIDCleared returns if the edge User_ID was cleared.
func (m *PreemptionMutation) UserIDCleared() bool {
	return m.cleared_User_ID
}

// UserIDID returns the User_ID id in the mutation.
func (m *PreemptionMutation) UserIDID() (id int, exists bool) {
	if m._User_ID != nil {
		return *m._User_ID, true
	}
	return
}

// UserIDIDs returns the User_ID ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserIDID instead. It exists only for internal usage by the builders.
func (m *PreemptionMutation) UserIDIDs() (ids []int) {
	if id := m._User_ID; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserID reset all changes of the "User_ID" edge.
func (m *PreemptionMutation) ResetUserID() {
	m._User_ID = nil
	m.cleared_User_ID = false
}

// SetPurposeIDID sets the PurposeID edge to Purpose by id.
func (m *PreemptionMutation) SetPurposeIDID(id int) {
	m._PurposeID = &id
}

// ClearPurposeID clears the PurposeID edge to Purpose.
func (m *PreemptionMutation) ClearPurposeID() {
	m.cleared_PurposeID = true
}

// PurposeIDCleared returns if the edge PurposeID was cleared.
func (m *PreemptionMutation) PurposeIDCleared() bool {
	return m.cleared_PurposeID
}

// PurposeIDID returns the PurposeID id in the mutation.
func (m *PreemptionMutation) PurposeIDID() (id int, exists bool) {
	if m._PurposeID != nil {
		return *m._PurposeID, true
	}
	return
}

// PurposeIDIDs returns the PurposeID ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PurposeIDID instead. It exists only for internal usage by the builders.
func (m *PreemptionMutation) PurposeIDIDs() (ids []int) {
	if id := m._PurposeID; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPurposeID reset all changes of the "PurposeID" edge.
func (m *PreemptionMutation) ResetPurposeID() {
	m._PurposeID = nil
	m.cleared_PurposeID = false
}

// SetRoomIDID sets the RoomID edge to Roominfo by id.
func (m *PreemptionMutation) SetRoomIDID(id int) {
	m._RoomID = &id
}

// ClearRoomID clears the RoomID edge to Roominfo.
func (m *PreemptionMutation) ClearRoomID() {
	m.cleared_RoomID = true
}

// RoomIDCleared returns if the edge RoomID was cleared.
func (m *PreemptionMutation) RoomIDCleared() bool {
	return m.cleared_RoomID
}

// RoomIDID returns the RoomID id in the mutation.
func (m *PreemptionMutation) RoomIDID() (id int, exists bool) {
	if m._RoomID != nil {
		return *m._RoomID, true
	}
	return
}

// RoomIDIDs returns the RoomID ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomIDID instead. It exists only for internal usage by the builders.
func (m *PreemptionMutation) RoomIDIDs() (ids []int) {
	if id := m._RoomID; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomID reset all changes of the "RoomID" edge.
func (m *PreemptionMutation) ResetRoomID() {
	m._RoomID = nil
	m.cleared_RoomID = false
}

// Op returns the operation name.
func (m *PreemptionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Preemption).
func (m *PreemptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PreemptionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._PreemptTime != nil {
		fields = append(fields, preemption.FieldPreemptTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PreemptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case preemption.FieldPreemptTime:
		return m.PreemptTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PreemptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case preemption.FieldPreemptTime:
		return m.OldPreemptTime(ctx)
	}
	return nil, fmt.Errorf("unknown Preemption field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PreemptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case preemption.FieldPreemptTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreemptTime(v)
		return nil
	}
	return fmt.Errorf("unknown Preemption field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PreemptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PreemptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PreemptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Preemption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PreemptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PreemptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PreemptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Preemption nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PreemptionMutation) ResetField(name string) error {
	switch name {
	case preemption.FieldPreemptTime:
		m.ResetPreemptTime()
		return nil
	}
	return fmt.Errorf("unknown Preemption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PreemptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._User_ID != nil {
		edges = append(edges, preemption.EdgeUserID)
	}
	if m._PurposeID != nil {
		edges = append(edges, preemption.EdgePurposeID)
	}
	if m._RoomID != nil {
		edges = append(edges, preemption.EdgeRoomID)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PreemptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case preemption.EdgeUserID:
		if id := m._User_ID; id != nil {
			return []ent.Value{*id}
		}
	case preemption.EdgePurposeID:
		if id := m._PurposeID; id != nil {
			return []ent.Value{*id}
		}
	case preemption.EdgeRoomID:
		if id := m._RoomID; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PreemptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PreemptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PreemptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_User_ID {
		edges = append(edges, preemption.EdgeUserID)
	}
	if m.cleared_PurposeID {
		edges = append(edges, preemption.EdgePurposeID)
	}
	if m.cleared_RoomID {
		edges = append(edges, preemption.EdgeRoomID)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PreemptionMutation) EdgeCleared(name string) bool {
	switch name {
	case preemption.EdgeUserID:
		return m.cleared_User_ID
	case preemption.EdgePurposeID:
		return m.cleared_PurposeID
	case preemption.EdgeRoomID:
		return m.cleared_RoomID
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PreemptionMutation) ClearEdge(name string) error {
	switch name {
	case preemption.EdgeUserID:
		m.ClearUserID()
		return nil
	case preemption.EdgePurposeID:
		m.ClearPurposeID()
		return nil
	case preemption.EdgeRoomID:
		m.ClearRoomID()
		return nil
	}
	return fmt.Errorf("unknown Preemption unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PreemptionMutation) ResetEdge(name string) error {
	switch name {
	case preemption.EdgeUserID:
		m.ResetUserID()
		return nil
	case preemption.EdgePurposeID:
		m.ResetPurposeID()
		return nil
	case preemption.EdgeRoomID:
		m.ResetRoomID()
		return nil
	}
	return fmt.Errorf("unknown Preemption edge %s", name)
}

// PurposeMutation represents an operation that mutate the Purposes
// nodes in the graph.
type PurposeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_PurposeName      *string
	clearedFields     map[string]struct{}
	preemption        map[int]struct{}
	removedpreemption map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Purpose, error)
}

var _ ent.Mutation = (*PurposeMutation)(nil)

// purposeOption allows to manage the mutation configuration using functional options.
type purposeOption func(*PurposeMutation)

// newPurposeMutation creates new mutation for $n.Name.
func newPurposeMutation(c config, op Op, opts ...purposeOption) *PurposeMutation {
	m := &PurposeMutation{
		config:        c,
		op:            op,
		typ:           TypePurpose,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPurposeID sets the id field of the mutation.
func withPurposeID(id int) purposeOption {
	return func(m *PurposeMutation) {
		var (
			err   error
			once  sync.Once
			value *Purpose
		)
		m.oldValue = func(ctx context.Context) (*Purpose, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Purpose.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPurpose sets the old Purpose of the mutation.
func withPurpose(node *Purpose) purposeOption {
	return func(m *PurposeMutation) {
		m.oldValue = func(context.Context) (*Purpose, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PurposeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PurposeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PurposeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPurposeName sets the PurposeName field.
func (m *PurposeMutation) SetPurposeName(s string) {
	m._PurposeName = &s
}

// PurposeName returns the PurposeName value in the mutation.
func (m *PurposeMutation) PurposeName() (r string, exists bool) {
	v := m._PurposeName
	if v == nil {
		return
	}
	return *v, true
}

// OldPurposeName returns the old PurposeName value of the Purpose.
// If the Purpose object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PurposeMutation) OldPurposeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPurposeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPurposeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurposeName: %w", err)
	}
	return oldValue.PurposeName, nil
}

// ResetPurposeName reset all changes of the "PurposeName" field.
func (m *PurposeMutation) ResetPurposeName() {
	m._PurposeName = nil
}

// AddPreemptionIDs adds the preemption edge to Preemption by ids.
func (m *PurposeMutation) AddPreemptionIDs(ids ...int) {
	if m.preemption == nil {
		m.preemption = make(map[int]struct{})
	}
	for i := range ids {
		m.preemption[ids[i]] = struct{}{}
	}
}

// RemovePreemptionIDs removes the preemption edge to Preemption by ids.
func (m *PurposeMutation) RemovePreemptionIDs(ids ...int) {
	if m.removedpreemption == nil {
		m.removedpreemption = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpreemption[ids[i]] = struct{}{}
	}
}

// RemovedPreemption returns the removed ids of preemption.
func (m *PurposeMutation) RemovedPreemptionIDs() (ids []int) {
	for id := range m.removedpreemption {
		ids = append(ids, id)
	}
	return
}

// PreemptionIDs returns the preemption ids in the mutation.
func (m *PurposeMutation) PreemptionIDs() (ids []int) {
	for id := range m.preemption {
		ids = append(ids, id)
	}
	return
}

// ResetPreemption reset all changes of the "preemption" edge.
func (m *PurposeMutation) ResetPreemption() {
	m.preemption = nil
	m.removedpreemption = nil
}

// Op returns the operation name.
func (m *PurposeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Purpose).
func (m *PurposeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PurposeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._PurposeName != nil {
		fields = append(fields, purpose.FieldPurposeName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PurposeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case purpose.FieldPurposeName:
		return m.PurposeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PurposeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case purpose.FieldPurposeName:
		return m.OldPurposeName(ctx)
	}
	return nil, fmt.Errorf("unknown Purpose field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PurposeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case purpose.FieldPurposeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurposeName(v)
		return nil
	}
	return fmt.Errorf("unknown Purpose field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PurposeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PurposeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PurposeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Purpose numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PurposeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PurposeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PurposeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Purpose nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PurposeMutation) ResetField(name string) error {
	switch name {
	case purpose.FieldPurposeName:
		m.ResetPurposeName()
		return nil
	}
	return fmt.Errorf("unknown Purpose field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PurposeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.preemption != nil {
		edges = append(edges, purpose.EdgePreemption)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PurposeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case purpose.EdgePreemption:
		ids := make([]ent.Value, 0, len(m.preemption))
		for id := range m.preemption {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PurposeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpreemption != nil {
		edges = append(edges, purpose.EdgePreemption)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PurposeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case purpose.EdgePreemption:
		ids := make([]ent.Value, 0, len(m.removedpreemption))
		for id := range m.removedpreemption {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PurposeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PurposeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PurposeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Purpose unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PurposeMutation) ResetEdge(name string) error {
	switch name {
	case purpose.EdgePreemption:
		m.ResetPreemption()
		return nil
	}
	return fmt.Errorf("unknown Purpose edge %s", name)
}

// ResearchMutation represents an operation that mutate the Researches
// nodes in the graph.
type ResearchMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_DOC_NAME       *string
	_DATE           *time.Time
	clearedFields   map[string]struct{}
	register        *int
	clearedregister bool
	myDoc           *int
	clearedmyDoc    bool
	docType         *int
	cleareddocType  bool
	done            bool
	oldValue        func(context.Context) (*Research, error)
}

var _ ent.Mutation = (*ResearchMutation)(nil)

// researchOption allows to manage the mutation configuration using functional options.
type researchOption func(*ResearchMutation)

// newResearchMutation creates new mutation for $n.Name.
func newResearchMutation(c config, op Op, opts ...researchOption) *ResearchMutation {
	m := &ResearchMutation{
		config:        c,
		op:            op,
		typ:           TypeResearch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResearchID sets the id field of the mutation.
func withResearchID(id int) researchOption {
	return func(m *ResearchMutation) {
		var (
			err   error
			once  sync.Once
			value *Research
		)
		m.oldValue = func(ctx context.Context) (*Research, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Research.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResearch sets the old Research of the mutation.
func withResearch(node *Research) researchOption {
	return func(m *ResearchMutation) {
		m.oldValue = func(context.Context) (*Research, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResearchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResearchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ResearchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDOCNAME sets the DOC_NAME field.
func (m *ResearchMutation) SetDOCNAME(s string) {
	m._DOC_NAME = &s
}

// DOCNAME returns the DOC_NAME value in the mutation.
func (m *ResearchMutation) DOCNAME() (r string, exists bool) {
	v := m._DOC_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldDOCNAME returns the old DOC_NAME value of the Research.
// If the Research object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResearchMutation) OldDOCNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDOCNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDOCNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOCNAME: %w", err)
	}
	return oldValue.DOCNAME, nil
}

// ResetDOCNAME reset all changes of the "DOC_NAME" field.
func (m *ResearchMutation) ResetDOCNAME() {
	m._DOC_NAME = nil
}

// SetDATE sets the DATE field.
func (m *ResearchMutation) SetDATE(t time.Time) {
	m._DATE = &t
}

// DATE returns the DATE value in the mutation.
func (m *ResearchMutation) DATE() (r time.Time, exists bool) {
	v := m._DATE
	if v == nil {
		return
	}
	return *v, true
}

// OldDATE returns the old DATE value of the Research.
// If the Research object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResearchMutation) OldDATE(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDATE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDATE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDATE: %w", err)
	}
	return oldValue.DATE, nil
}

// ResetDATE reset all changes of the "DATE" field.
func (m *ResearchMutation) ResetDATE() {
	m._DATE = nil
}

// SetRegisterID sets the register edge to User by id.
func (m *ResearchMutation) SetRegisterID(id int) {
	m.register = &id
}

// ClearRegister clears the register edge to User.
func (m *ResearchMutation) ClearRegister() {
	m.clearedregister = true
}

// RegisterCleared returns if the edge register was cleared.
func (m *ResearchMutation) RegisterCleared() bool {
	return m.clearedregister
}

// RegisterID returns the register id in the mutation.
func (m *ResearchMutation) RegisterID() (id int, exists bool) {
	if m.register != nil {
		return *m.register, true
	}
	return
}

// RegisterIDs returns the register ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RegisterID instead. It exists only for internal usage by the builders.
func (m *ResearchMutation) RegisterIDs() (ids []int) {
	if id := m.register; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegister reset all changes of the "register" edge.
func (m *ResearchMutation) ResetRegister() {
	m.register = nil
	m.clearedregister = false
}

// SetMyDocID sets the myDoc edge to Author by id.
func (m *ResearchMutation) SetMyDocID(id int) {
	m.myDoc = &id
}

// ClearMyDoc clears the myDoc edge to Author.
func (m *ResearchMutation) ClearMyDoc() {
	m.clearedmyDoc = true
}

// MyDocCleared returns if the edge myDoc was cleared.
func (m *ResearchMutation) MyDocCleared() bool {
	return m.clearedmyDoc
}

// MyDocID returns the myDoc id in the mutation.
func (m *ResearchMutation) MyDocID() (id int, exists bool) {
	if m.myDoc != nil {
		return *m.myDoc, true
	}
	return
}

// MyDocIDs returns the myDoc ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MyDocID instead. It exists only for internal usage by the builders.
func (m *ResearchMutation) MyDocIDs() (ids []int) {
	if id := m.myDoc; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMyDoc reset all changes of the "myDoc" edge.
func (m *ResearchMutation) ResetMyDoc() {
	m.myDoc = nil
	m.clearedmyDoc = false
}

// SetDocTypeID sets the docType edge to Researchtype by id.
func (m *ResearchMutation) SetDocTypeID(id int) {
	m.docType = &id
}

// ClearDocType clears the docType edge to Researchtype.
func (m *ResearchMutation) ClearDocType() {
	m.cleareddocType = true
}

// DocTypeCleared returns if the edge docType was cleared.
func (m *ResearchMutation) DocTypeCleared() bool {
	return m.cleareddocType
}

// DocTypeID returns the docType id in the mutation.
func (m *ResearchMutation) DocTypeID() (id int, exists bool) {
	if m.docType != nil {
		return *m.docType, true
	}
	return
}

// DocTypeIDs returns the docType ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DocTypeID instead. It exists only for internal usage by the builders.
func (m *ResearchMutation) DocTypeIDs() (ids []int) {
	if id := m.docType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocType reset all changes of the "docType" edge.
func (m *ResearchMutation) ResetDocType() {
	m.docType = nil
	m.cleareddocType = false
}

// Op returns the operation name.
func (m *ResearchMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Research).
func (m *ResearchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ResearchMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._DOC_NAME != nil {
		fields = append(fields, research.FieldDOCNAME)
	}
	if m._DATE != nil {
		fields = append(fields, research.FieldDATE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ResearchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case research.FieldDOCNAME:
		return m.DOCNAME()
	case research.FieldDATE:
		return m.DATE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ResearchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case research.FieldDOCNAME:
		return m.OldDOCNAME(ctx)
	case research.FieldDATE:
		return m.OldDATE(ctx)
	}
	return nil, fmt.Errorf("unknown Research field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResearchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case research.FieldDOCNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOCNAME(v)
		return nil
	case research.FieldDATE:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDATE(v)
		return nil
	}
	return fmt.Errorf("unknown Research field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ResearchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ResearchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResearchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Research numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ResearchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ResearchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResearchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Research nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ResearchMutation) ResetField(name string) error {
	switch name {
	case research.FieldDOCNAME:
		m.ResetDOCNAME()
		return nil
	case research.FieldDATE:
		m.ResetDATE()
		return nil
	}
	return fmt.Errorf("unknown Research field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ResearchMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.register != nil {
		edges = append(edges, research.EdgeRegister)
	}
	if m.myDoc != nil {
		edges = append(edges, research.EdgeMyDoc)
	}
	if m.docType != nil {
		edges = append(edges, research.EdgeDocType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ResearchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case research.EdgeRegister:
		if id := m.register; id != nil {
			return []ent.Value{*id}
		}
	case research.EdgeMyDoc:
		if id := m.myDoc; id != nil {
			return []ent.Value{*id}
		}
	case research.EdgeDocType:
		if id := m.docType; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ResearchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ResearchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ResearchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedregister {
		edges = append(edges, research.EdgeRegister)
	}
	if m.clearedmyDoc {
		edges = append(edges, research.EdgeMyDoc)
	}
	if m.cleareddocType {
		edges = append(edges, research.EdgeDocType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ResearchMutation) EdgeCleared(name string) bool {
	switch name {
	case research.EdgeRegister:
		return m.clearedregister
	case research.EdgeMyDoc:
		return m.clearedmyDoc
	case research.EdgeDocType:
		return m.cleareddocType
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ResearchMutation) ClearEdge(name string) error {
	switch name {
	case research.EdgeRegister:
		m.ClearRegister()
		return nil
	case research.EdgeMyDoc:
		m.ClearMyDoc()
		return nil
	case research.EdgeDocType:
		m.ClearDocType()
		return nil
	}
	return fmt.Errorf("unknown Research unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ResearchMutation) ResetEdge(name string) error {
	switch name {
	case research.EdgeRegister:
		m.ResetRegister()
		return nil
	case research.EdgeMyDoc:
		m.ResetMyDoc()
		return nil
	case research.EdgeDocType:
		m.ResetDocType()
		return nil
	}
	return fmt.Errorf("unknown Research edge %s", name)
}

// ResearchtypeMutation represents an operation that mutate the Researchtypes
// nodes in the graph.
type ResearchtypeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_TYPE_NAME          *string
	clearedFields       map[string]struct{}
	researchType        map[int]struct{}
	removedresearchType map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*Researchtype, error)
}

var _ ent.Mutation = (*ResearchtypeMutation)(nil)

// researchtypeOption allows to manage the mutation configuration using functional options.
type researchtypeOption func(*ResearchtypeMutation)

// newResearchtypeMutation creates new mutation for $n.Name.
func newResearchtypeMutation(c config, op Op, opts ...researchtypeOption) *ResearchtypeMutation {
	m := &ResearchtypeMutation{
		config:        c,
		op:            op,
		typ:           TypeResearchtype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResearchtypeID sets the id field of the mutation.
func withResearchtypeID(id int) researchtypeOption {
	return func(m *ResearchtypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Researchtype
		)
		m.oldValue = func(ctx context.Context) (*Researchtype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Researchtype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResearchtype sets the old Researchtype of the mutation.
func withResearchtype(node *Researchtype) researchtypeOption {
	return func(m *ResearchtypeMutation) {
		m.oldValue = func(context.Context) (*Researchtype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResearchtypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResearchtypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ResearchtypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTYPENAME sets the TYPE_NAME field.
func (m *ResearchtypeMutation) SetTYPENAME(s string) {
	m._TYPE_NAME = &s
}

// TYPENAME returns the TYPE_NAME value in the mutation.
func (m *ResearchtypeMutation) TYPENAME() (r string, exists bool) {
	v := m._TYPE_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldTYPENAME returns the old TYPE_NAME value of the Researchtype.
// If the Researchtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResearchtypeMutation) OldTYPENAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTYPENAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTYPENAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTYPENAME: %w", err)
	}
	return oldValue.TYPENAME, nil
}

// ResetTYPENAME reset all changes of the "TYPE_NAME" field.
func (m *ResearchtypeMutation) ResetTYPENAME() {
	m._TYPE_NAME = nil
}

// AddResearchTypeIDs adds the researchType edge to Research by ids.
func (m *ResearchtypeMutation) AddResearchTypeIDs(ids ...int) {
	if m.researchType == nil {
		m.researchType = make(map[int]struct{})
	}
	for i := range ids {
		m.researchType[ids[i]] = struct{}{}
	}
}

// RemoveResearchTypeIDs removes the researchType edge to Research by ids.
func (m *ResearchtypeMutation) RemoveResearchTypeIDs(ids ...int) {
	if m.removedresearchType == nil {
		m.removedresearchType = make(map[int]struct{})
	}
	for i := range ids {
		m.removedresearchType[ids[i]] = struct{}{}
	}
}

// RemovedResearchType returns the removed ids of researchType.
func (m *ResearchtypeMutation) RemovedResearchTypeIDs() (ids []int) {
	for id := range m.removedresearchType {
		ids = append(ids, id)
	}
	return
}

// ResearchTypeIDs returns the researchType ids in the mutation.
func (m *ResearchtypeMutation) ResearchTypeIDs() (ids []int) {
	for id := range m.researchType {
		ids = append(ids, id)
	}
	return
}

// ResetResearchType reset all changes of the "researchType" edge.
func (m *ResearchtypeMutation) ResetResearchType() {
	m.researchType = nil
	m.removedresearchType = nil
}

// Op returns the operation name.
func (m *ResearchtypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Researchtype).
func (m *ResearchtypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ResearchtypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TYPE_NAME != nil {
		fields = append(fields, researchtype.FieldTYPENAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ResearchtypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case researchtype.FieldTYPENAME:
		return m.TYPENAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ResearchtypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case researchtype.FieldTYPENAME:
		return m.OldTYPENAME(ctx)
	}
	return nil, fmt.Errorf("unknown Researchtype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResearchtypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case researchtype.FieldTYPENAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTYPENAME(v)
		return nil
	}
	return fmt.Errorf("unknown Researchtype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ResearchtypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ResearchtypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResearchtypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Researchtype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ResearchtypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ResearchtypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResearchtypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Researchtype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ResearchtypeMutation) ResetField(name string) error {
	switch name {
	case researchtype.FieldTYPENAME:
		m.ResetTYPENAME()
		return nil
	}
	return fmt.Errorf("unknown Researchtype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ResearchtypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.researchType != nil {
		edges = append(edges, researchtype.EdgeResearchType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ResearchtypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case researchtype.EdgeResearchType:
		ids := make([]ent.Value, 0, len(m.researchType))
		for id := range m.researchType {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ResearchtypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedresearchType != nil {
		edges = append(edges, researchtype.EdgeResearchType)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ResearchtypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case researchtype.EdgeResearchType:
		ids := make([]ent.Value, 0, len(m.removedresearchType))
		for id := range m.removedresearchType {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ResearchtypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ResearchtypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ResearchtypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Researchtype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ResearchtypeMutation) ResetEdge(name string) error {
	switch name {
	case researchtype.EdgeResearchType:
		m.ResetResearchType()
		return nil
	}
	return fmt.Errorf("unknown Researchtype edge %s", name)
}

// RoleMutation represents an operation that mutate the Roles
// nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_ROLE_NAME    *string
	clearedFields map[string]struct{}
	role          map[int]struct{}
	removedrole   map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Role, error)
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows to manage the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for $n.Name.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the id field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetROLENAME sets the ROLE_NAME field.
func (m *RoleMutation) SetROLENAME(s string) {
	m._ROLE_NAME = &s
}

// ROLENAME returns the ROLE_NAME value in the mutation.
func (m *RoleMutation) ROLENAME() (r string, exists bool) {
	v := m._ROLE_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldROLENAME returns the old ROLE_NAME value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldROLENAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldROLENAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldROLENAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldROLENAME: %w", err)
	}
	return oldValue.ROLENAME, nil
}

// ResetROLENAME reset all changes of the "ROLE_NAME" field.
func (m *RoleMutation) ResetROLENAME() {
	m._ROLE_NAME = nil
}

// AddRoleIDs adds the role edge to User by ids.
func (m *RoleMutation) AddRoleIDs(ids ...int) {
	if m.role == nil {
		m.role = make(map[int]struct{})
	}
	for i := range ids {
		m.role[ids[i]] = struct{}{}
	}
}

// RemoveRoleIDs removes the role edge to User by ids.
func (m *RoleMutation) RemoveRoleIDs(ids ...int) {
	if m.removedrole == nil {
		m.removedrole = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrole[ids[i]] = struct{}{}
	}
}

// RemovedRole returns the removed ids of role.
func (m *RoleMutation) RemovedRoleIDs() (ids []int) {
	for id := range m.removedrole {
		ids = append(ids, id)
	}
	return
}

// RoleIDs returns the role ids in the mutation.
func (m *RoleMutation) RoleIDs() (ids []int) {
	for id := range m.role {
		ids = append(ids, id)
	}
	return
}

// ResetRole reset all changes of the "role" edge.
func (m *RoleMutation) ResetRole() {
	m.role = nil
	m.removedrole = nil
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._ROLE_NAME != nil {
		fields = append(fields, role.FieldROLENAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldROLENAME:
		return m.ROLENAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldROLENAME:
		return m.OldROLENAME(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldROLENAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetROLENAME(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldROLENAME:
		m.ResetROLENAME()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role != nil {
		edges = append(edges, role.EdgeRole)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRole:
		ids := make([]ent.Value, 0, len(m.role))
		for id := range m.role {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrole != nil {
		edges = append(edges, role.EdgeRole)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRole:
		ids := make([]ent.Value, 0, len(m.removedrole))
		for id := range m.removedrole {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// RoominfoMutation represents an operation that mutate the Roominfos
// nodes in the graph.
type RoominfoMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_RoomID           *string
	_RoomNo           *string
	_RoomType         *string
	_RoomTime         *string
	_RoomStatus       *string
	clearedFields     map[string]struct{}
	preemption        map[int]struct{}
	removedpreemption map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Roominfo, error)
}

var _ ent.Mutation = (*RoominfoMutation)(nil)

// roominfoOption allows to manage the mutation configuration using functional options.
type roominfoOption func(*RoominfoMutation)

// newRoominfoMutation creates new mutation for $n.Name.
func newRoominfoMutation(c config, op Op, opts ...roominfoOption) *RoominfoMutation {
	m := &RoominfoMutation{
		config:        c,
		op:            op,
		typ:           TypeRoominfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoominfoID sets the id field of the mutation.
func withRoominfoID(id int) roominfoOption {
	return func(m *RoominfoMutation) {
		var (
			err   error
			once  sync.Once
			value *Roominfo
		)
		m.oldValue = func(ctx context.Context) (*Roominfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Roominfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoominfo sets the old Roominfo of the mutation.
func withRoominfo(node *Roominfo) roominfoOption {
	return func(m *RoominfoMutation) {
		m.oldValue = func(context.Context) (*Roominfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoominfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoominfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoominfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomID sets the RoomID field.
func (m *RoominfoMutation) SetRoomID(s string) {
	m._RoomID = &s
}

// RoomID returns the RoomID value in the mutation.
func (m *RoominfoMutation) RoomID() (r string, exists bool) {
	v := m._RoomID
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomID returns the old RoomID value of the Roominfo.
// If the Roominfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoominfoMutation) OldRoomID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomID: %w", err)
	}
	return oldValue.RoomID, nil
}

// ResetRoomID reset all changes of the "RoomID" field.
func (m *RoominfoMutation) ResetRoomID() {
	m._RoomID = nil
}

// SetRoomNo sets the RoomNo field.
func (m *RoominfoMutation) SetRoomNo(s string) {
	m._RoomNo = &s
}

// RoomNo returns the RoomNo value in the mutation.
func (m *RoominfoMutation) RoomNo() (r string, exists bool) {
	v := m._RoomNo
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomNo returns the old RoomNo value of the Roominfo.
// If the Roominfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoominfoMutation) OldRoomNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomNo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomNo: %w", err)
	}
	return oldValue.RoomNo, nil
}

// ResetRoomNo reset all changes of the "RoomNo" field.
func (m *RoominfoMutation) ResetRoomNo() {
	m._RoomNo = nil
}

// SetRoomType sets the RoomType field.
func (m *RoominfoMutation) SetRoomType(s string) {
	m._RoomType = &s
}

// RoomType returns the RoomType value in the mutation.
func (m *RoominfoMutation) RoomType() (r string, exists bool) {
	v := m._RoomType
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomType returns the old RoomType value of the Roominfo.
// If the Roominfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoominfoMutation) OldRoomType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomType: %w", err)
	}
	return oldValue.RoomType, nil
}

// ResetRoomType reset all changes of the "RoomType" field.
func (m *RoominfoMutation) ResetRoomType() {
	m._RoomType = nil
}

// SetRoomTime sets the RoomTime field.
func (m *RoominfoMutation) SetRoomTime(s string) {
	m._RoomTime = &s
}

// RoomTime returns the RoomTime value in the mutation.
func (m *RoominfoMutation) RoomTime() (r string, exists bool) {
	v := m._RoomTime
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomTime returns the old RoomTime value of the Roominfo.
// If the Roominfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoominfoMutation) OldRoomTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomTime: %w", err)
	}
	return oldValue.RoomTime, nil
}

// ResetRoomTime reset all changes of the "RoomTime" field.
func (m *RoominfoMutation) ResetRoomTime() {
	m._RoomTime = nil
}

// SetRoomStatus sets the RoomStatus field.
func (m *RoominfoMutation) SetRoomStatus(s string) {
	m._RoomStatus = &s
}

// RoomStatus returns the RoomStatus value in the mutation.
func (m *RoominfoMutation) RoomStatus() (r string, exists bool) {
	v := m._RoomStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomStatus returns the old RoomStatus value of the Roominfo.
// If the Roominfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoominfoMutation) OldRoomStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomStatus: %w", err)
	}
	return oldValue.RoomStatus, nil
}

// ResetRoomStatus reset all changes of the "RoomStatus" field.
func (m *RoominfoMutation) ResetRoomStatus() {
	m._RoomStatus = nil
}

// AddPreemptionIDs adds the preemption edge to Preemption by ids.
func (m *RoominfoMutation) AddPreemptionIDs(ids ...int) {
	if m.preemption == nil {
		m.preemption = make(map[int]struct{})
	}
	for i := range ids {
		m.preemption[ids[i]] = struct{}{}
	}
}

// RemovePreemptionIDs removes the preemption edge to Preemption by ids.
func (m *RoominfoMutation) RemovePreemptionIDs(ids ...int) {
	if m.removedpreemption == nil {
		m.removedpreemption = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpreemption[ids[i]] = struct{}{}
	}
}

// RemovedPreemption returns the removed ids of preemption.
func (m *RoominfoMutation) RemovedPreemptionIDs() (ids []int) {
	for id := range m.removedpreemption {
		ids = append(ids, id)
	}
	return
}

// PreemptionIDs returns the preemption ids in the mutation.
func (m *RoominfoMutation) PreemptionIDs() (ids []int) {
	for id := range m.preemption {
		ids = append(ids, id)
	}
	return
}

// ResetPreemption reset all changes of the "preemption" edge.
func (m *RoominfoMutation) ResetPreemption() {
	m.preemption = nil
	m.removedpreemption = nil
}

// Op returns the operation name.
func (m *RoominfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Roominfo).
func (m *RoominfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoominfoMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._RoomID != nil {
		fields = append(fields, roominfo.FieldRoomID)
	}
	if m._RoomNo != nil {
		fields = append(fields, roominfo.FieldRoomNo)
	}
	if m._RoomType != nil {
		fields = append(fields, roominfo.FieldRoomType)
	}
	if m._RoomTime != nil {
		fields = append(fields, roominfo.FieldRoomTime)
	}
	if m._RoomStatus != nil {
		fields = append(fields, roominfo.FieldRoomStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoominfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roominfo.FieldRoomID:
		return m.RoomID()
	case roominfo.FieldRoomNo:
		return m.RoomNo()
	case roominfo.FieldRoomType:
		return m.RoomType()
	case roominfo.FieldRoomTime:
		return m.RoomTime()
	case roominfo.FieldRoomStatus:
		return m.RoomStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoominfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roominfo.FieldRoomID:
		return m.OldRoomID(ctx)
	case roominfo.FieldRoomNo:
		return m.OldRoomNo(ctx)
	case roominfo.FieldRoomType:
		return m.OldRoomType(ctx)
	case roominfo.FieldRoomTime:
		return m.OldRoomTime(ctx)
	case roominfo.FieldRoomStatus:
		return m.OldRoomStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Roominfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoominfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roominfo.FieldRoomID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomID(v)
		return nil
	case roominfo.FieldRoomNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomNo(v)
		return nil
	case roominfo.FieldRoomType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomType(v)
		return nil
	case roominfo.FieldRoomTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomTime(v)
		return nil
	case roominfo.FieldRoomStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Roominfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoominfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoominfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoominfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Roominfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoominfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoominfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoominfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Roominfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoominfoMutation) ResetField(name string) error {
	switch name {
	case roominfo.FieldRoomID:
		m.ResetRoomID()
		return nil
	case roominfo.FieldRoomNo:
		m.ResetRoomNo()
		return nil
	case roominfo.FieldRoomType:
		m.ResetRoomType()
		return nil
	case roominfo.FieldRoomTime:
		m.ResetRoomTime()
		return nil
	case roominfo.FieldRoomStatus:
		m.ResetRoomStatus()
		return nil
	}
	return fmt.Errorf("unknown Roominfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoominfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.preemption != nil {
		edges = append(edges, roominfo.EdgePreemption)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoominfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roominfo.EdgePreemption:
		ids := make([]ent.Value, 0, len(m.preemption))
		for id := range m.preemption {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoominfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpreemption != nil {
		edges = append(edges, roominfo.EdgePreemption)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoominfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case roominfo.EdgePreemption:
		ids := make([]ent.Value, 0, len(m.removedpreemption))
		for id := range m.removedpreemption {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoominfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoominfoMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoominfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Roominfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoominfoMutation) ResetEdge(name string) error {
	switch name {
	case roominfo.EdgePreemption:
		m.ResetPreemption()
		return nil
	}
	return fmt.Errorf("unknown Roominfo edge %s", name)
}

// ServicePointMutation represents an operation that mutate the ServicePoints
// nodes in the graph.
type ServicePointMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_COUNTER_NUMBER     *string
	clearedFields       map[string]struct{}
	from                map[int]struct{}
	removedfrom         map[int]struct{}
	servicepoint        map[int]struct{}
	removedservicepoint map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*ServicePoint, error)
}

var _ ent.Mutation = (*ServicePointMutation)(nil)

// servicepointOption allows to manage the mutation configuration using functional options.
type servicepointOption func(*ServicePointMutation)

// newServicePointMutation creates new mutation for $n.Name.
func newServicePointMutation(c config, op Op, opts ...servicepointOption) *ServicePointMutation {
	m := &ServicePointMutation{
		config:        c,
		op:            op,
		typ:           TypeServicePoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServicePointID sets the id field of the mutation.
func withServicePointID(id int) servicepointOption {
	return func(m *ServicePointMutation) {
		var (
			err   error
			once  sync.Once
			value *ServicePoint
		)
		m.oldValue = func(ctx context.Context) (*ServicePoint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServicePoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServicePoint sets the old ServicePoint of the mutation.
func withServicePoint(node *ServicePoint) servicepointOption {
	return func(m *ServicePointMutation) {
		m.oldValue = func(context.Context) (*ServicePoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServicePointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServicePointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServicePointMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCOUNTERNUMBER sets the COUNTER_NUMBER field.
func (m *ServicePointMutation) SetCOUNTERNUMBER(s string) {
	m._COUNTER_NUMBER = &s
}

// COUNTERNUMBER returns the COUNTER_NUMBER value in the mutation.
func (m *ServicePointMutation) COUNTERNUMBER() (r string, exists bool) {
	v := m._COUNTER_NUMBER
	if v == nil {
		return
	}
	return *v, true
}

// OldCOUNTERNUMBER returns the old COUNTER_NUMBER value of the ServicePoint.
// If the ServicePoint object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServicePointMutation) OldCOUNTERNUMBER(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCOUNTERNUMBER is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCOUNTERNUMBER requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCOUNTERNUMBER: %w", err)
	}
	return oldValue.COUNTERNUMBER, nil
}

// ResetCOUNTERNUMBER reset all changes of the "COUNTER_NUMBER" field.
func (m *ServicePointMutation) ResetCOUNTERNUMBER() {
	m._COUNTER_NUMBER = nil
}

// AddFromIDs adds the from edge to Bookborrow by ids.
func (m *ServicePointMutation) AddFromIDs(ids ...int) {
	if m.from == nil {
		m.from = make(map[int]struct{})
	}
	for i := range ids {
		m.from[ids[i]] = struct{}{}
	}
}

// RemoveFromIDs removes the from edge to Bookborrow by ids.
func (m *ServicePointMutation) RemoveFromIDs(ids ...int) {
	if m.removedfrom == nil {
		m.removedfrom = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfrom[ids[i]] = struct{}{}
	}
}

// RemovedFrom returns the removed ids of from.
func (m *ServicePointMutation) RemovedFromIDs() (ids []int) {
	for id := range m.removedfrom {
		ids = append(ids, id)
	}
	return
}

// FromIDs returns the from ids in the mutation.
func (m *ServicePointMutation) FromIDs() (ids []int) {
	for id := range m.from {
		ids = append(ids, id)
	}
	return
}

// ResetFrom reset all changes of the "from" edge.
func (m *ServicePointMutation) ResetFrom() {
	m.from = nil
	m.removedfrom = nil
}

// AddServicepointIDs adds the servicepoint edge to Booking by ids.
func (m *ServicePointMutation) AddServicepointIDs(ids ...int) {
	if m.servicepoint == nil {
		m.servicepoint = make(map[int]struct{})
	}
	for i := range ids {
		m.servicepoint[ids[i]] = struct{}{}
	}
}

// RemoveServicepointIDs removes the servicepoint edge to Booking by ids.
func (m *ServicePointMutation) RemoveServicepointIDs(ids ...int) {
	if m.removedservicepoint == nil {
		m.removedservicepoint = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservicepoint[ids[i]] = struct{}{}
	}
}

// RemovedServicepoint returns the removed ids of servicepoint.
func (m *ServicePointMutation) RemovedServicepointIDs() (ids []int) {
	for id := range m.removedservicepoint {
		ids = append(ids, id)
	}
	return
}

// ServicepointIDs returns the servicepoint ids in the mutation.
func (m *ServicePointMutation) ServicepointIDs() (ids []int) {
	for id := range m.servicepoint {
		ids = append(ids, id)
	}
	return
}

// ResetServicepoint reset all changes of the "servicepoint" edge.
func (m *ServicePointMutation) ResetServicepoint() {
	m.servicepoint = nil
	m.removedservicepoint = nil
}

// Op returns the operation name.
func (m *ServicePointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ServicePoint).
func (m *ServicePointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServicePointMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._COUNTER_NUMBER != nil {
		fields = append(fields, servicepoint.FieldCOUNTERNUMBER)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServicePointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicepoint.FieldCOUNTERNUMBER:
		return m.COUNTERNUMBER()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServicePointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicepoint.FieldCOUNTERNUMBER:
		return m.OldCOUNTERNUMBER(ctx)
	}
	return nil, fmt.Errorf("unknown ServicePoint field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServicePointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicepoint.FieldCOUNTERNUMBER:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCOUNTERNUMBER(v)
		return nil
	}
	return fmt.Errorf("unknown ServicePoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServicePointMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServicePointMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServicePointMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServicePoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServicePointMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServicePointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServicePointMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ServicePoint nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServicePointMutation) ResetField(name string) error {
	switch name {
	case servicepoint.FieldCOUNTERNUMBER:
		m.ResetCOUNTERNUMBER()
		return nil
	}
	return fmt.Errorf("unknown ServicePoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServicePointMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from != nil {
		edges = append(edges, servicepoint.EdgeFrom)
	}
	if m.servicepoint != nil {
		edges = append(edges, servicepoint.EdgeServicepoint)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServicePointMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicepoint.EdgeFrom:
		ids := make([]ent.Value, 0, len(m.from))
		for id := range m.from {
			ids = append(ids, id)
		}
		return ids
	case servicepoint.EdgeServicepoint:
		ids := make([]ent.Value, 0, len(m.servicepoint))
		for id := range m.servicepoint {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServicePointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfrom != nil {
		edges = append(edges, servicepoint.EdgeFrom)
	}
	if m.removedservicepoint != nil {
		edges = append(edges, servicepoint.EdgeServicepoint)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServicePointMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servicepoint.EdgeFrom:
		ids := make([]ent.Value, 0, len(m.removedfrom))
		for id := range m.removedfrom {
			ids = append(ids, id)
		}
		return ids
	case servicepoint.EdgeServicepoint:
		ids := make([]ent.Value, 0, len(m.removedservicepoint))
		for id := range m.removedservicepoint {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServicePointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServicePointMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServicePointMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServicePoint unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServicePointMutation) ResetEdge(name string) error {
	switch name {
	case servicepoint.EdgeFrom:
		m.ResetFrom()
		return nil
	case servicepoint.EdgeServicepoint:
		m.ResetServicepoint()
		return nil
	}
	return fmt.Errorf("unknown ServicePoint edge %s", name)
}

// StatusMutation represents an operation that mutate the StatusSlice
// nodes in the graph.
type StatusMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_STATUS_NAME        *string
	clearedFields       map[string]struct{}
	status              map[int]struct{}
	removedstatus       map[int]struct{}
	statusofbook        map[int]struct{}
	removedstatusofbook map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*Status, error)
}

var _ ent.Mutation = (*StatusMutation)(nil)

// statusOption allows to manage the mutation configuration using functional options.
type statusOption func(*StatusMutation)

// newStatusMutation creates new mutation for $n.Name.
func newStatusMutation(c config, op Op, opts ...statusOption) *StatusMutation {
	m := &StatusMutation{
		config:        c,
		op:            op,
		typ:           TypeStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusID sets the id field of the mutation.
func withStatusID(id int) statusOption {
	return func(m *StatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Status
		)
		m.oldValue = func(ctx context.Context) (*Status, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Status.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatus sets the old Status of the mutation.
func withStatus(node *Status) statusOption {
	return func(m *StatusMutation) {
		m.oldValue = func(context.Context) (*Status, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSTATUSNAME sets the STATUS_NAME field.
func (m *StatusMutation) SetSTATUSNAME(s string) {
	m._STATUS_NAME = &s
}

// STATUSNAME returns the STATUS_NAME value in the mutation.
func (m *StatusMutation) STATUSNAME() (r string, exists bool) {
	v := m._STATUS_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldSTATUSNAME returns the old STATUS_NAME value of the Status.
// If the Status object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusMutation) OldSTATUSNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSTATUSNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSTATUSNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSTATUSNAME: %w", err)
	}
	return oldValue.STATUSNAME, nil
}

// ResetSTATUSNAME reset all changes of the "STATUS_NAME" field.
func (m *StatusMutation) ResetSTATUSNAME() {
	m._STATUS_NAME = nil
}

// AddStatuIDs adds the status edge to ClientEntity by ids.
func (m *StatusMutation) AddStatuIDs(ids ...int) {
	if m.status == nil {
		m.status = make(map[int]struct{})
	}
	for i := range ids {
		m.status[ids[i]] = struct{}{}
	}
}

// RemoveStatuIDs removes the status edge to ClientEntity by ids.
func (m *StatusMutation) RemoveStatuIDs(ids ...int) {
	if m.removedstatus == nil {
		m.removedstatus = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatus[ids[i]] = struct{}{}
	}
}

// RemovedStatus returns the removed ids of status.
func (m *StatusMutation) RemovedStatusIDs() (ids []int) {
	for id := range m.removedstatus {
		ids = append(ids, id)
	}
	return
}

// StatusIDs returns the status ids in the mutation.
func (m *StatusMutation) StatusIDs() (ids []int) {
	for id := range m.status {
		ids = append(ids, id)
	}
	return
}

// ResetStatus reset all changes of the "status" edge.
func (m *StatusMutation) ResetStatus() {
	m.status = nil
	m.removedstatus = nil
}

// AddStatusofbookIDs adds the statusofbook edge to Book by ids.
func (m *StatusMutation) AddStatusofbookIDs(ids ...int) {
	if m.statusofbook == nil {
		m.statusofbook = make(map[int]struct{})
	}
	for i := range ids {
		m.statusofbook[ids[i]] = struct{}{}
	}
}

// RemoveStatusofbookIDs removes the statusofbook edge to Book by ids.
func (m *StatusMutation) RemoveStatusofbookIDs(ids ...int) {
	if m.removedstatusofbook == nil {
		m.removedstatusofbook = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatusofbook[ids[i]] = struct{}{}
	}
}

// RemovedStatusofbook returns the removed ids of statusofbook.
func (m *StatusMutation) RemovedStatusofbookIDs() (ids []int) {
	for id := range m.removedstatusofbook {
		ids = append(ids, id)
	}
	return
}

// StatusofbookIDs returns the statusofbook ids in the mutation.
func (m *StatusMutation) StatusofbookIDs() (ids []int) {
	for id := range m.statusofbook {
		ids = append(ids, id)
	}
	return
}

// ResetStatusofbook reset all changes of the "statusofbook" edge.
func (m *StatusMutation) ResetStatusofbook() {
	m.statusofbook = nil
	m.removedstatusofbook = nil
}

// Op returns the operation name.
func (m *StatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Status).
func (m *StatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._STATUS_NAME != nil {
		fields = append(fields, status.FieldSTATUSNAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case status.FieldSTATUSNAME:
		return m.STATUSNAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case status.FieldSTATUSNAME:
		return m.OldSTATUSNAME(ctx)
	}
	return nil, fmt.Errorf("unknown Status field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case status.FieldSTATUSNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSTATUSNAME(v)
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Status numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Status nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatusMutation) ResetField(name string) error {
	switch name {
	case status.FieldSTATUSNAME:
		m.ResetSTATUSNAME()
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.status != nil {
		edges = append(edges, status.EdgeStatus)
	}
	if m.statusofbook != nil {
		edges = append(edges, status.EdgeStatusofbook)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.status))
		for id := range m.status {
			ids = append(ids, id)
		}
		return ids
	case status.EdgeStatusofbook:
		ids := make([]ent.Value, 0, len(m.statusofbook))
		for id := range m.statusofbook {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedstatus != nil {
		edges = append(edges, status.EdgeStatus)
	}
	if m.removedstatusofbook != nil {
		edges = append(edges, status.EdgeStatusofbook)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.removedstatus))
		for id := range m.removedstatus {
			ids = append(ids, id)
		}
		return ids
	case status.EdgeStatusofbook:
		ids := make([]ent.Value, 0, len(m.removedstatusofbook))
		for id := range m.removedstatusofbook {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatusMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Status unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatusMutation) ResetEdge(name string) error {
	switch name {
	case status.EdgeStatus:
		m.ResetStatus()
		return nil
	case status.EdgeStatusofbook:
		m.ResetStatusofbook()
		return nil
	}
	return fmt.Errorf("unknown Status edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_USER_EMAIL       *string
	_USER_NAME        *string
	_PASSWORD         *string
	clearedFields     map[string]struct{}
	position          *int
	clearedposition   bool
	booking           map[int]struct{}
	removedbooking    map[int]struct{}
	addby             map[int]struct{}
	removedaddby      map[int]struct{}
	borrow            map[int]struct{}
	removedborrow     map[int]struct{}
	preemption        map[int]struct{}
	removedpreemption map[int]struct{}
	record            map[int]struct{}
	removedrecord     map[int]struct{}
	_return           map[int]struct{}
	removed_return    map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUSEREMAIL sets the USER_EMAIL field.
func (m *UserMutation) SetUSEREMAIL(s string) {
	m._USER_EMAIL = &s
}

// USEREMAIL returns the USER_EMAIL value in the mutation.
func (m *UserMutation) USEREMAIL() (r string, exists bool) {
	v := m._USER_EMAIL
	if v == nil {
		return
	}
	return *v, true
}

// OldUSEREMAIL returns the old USER_EMAIL value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUSEREMAIL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUSEREMAIL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUSEREMAIL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUSEREMAIL: %w", err)
	}
	return oldValue.USEREMAIL, nil
}

// ResetUSEREMAIL reset all changes of the "USER_EMAIL" field.
func (m *UserMutation) ResetUSEREMAIL() {
	m._USER_EMAIL = nil
}

// SetUSERNAME sets the USER_NAME field.
func (m *UserMutation) SetUSERNAME(s string) {
	m._USER_NAME = &s
}

// USERNAME returns the USER_NAME value in the mutation.
func (m *UserMutation) USERNAME() (r string, exists bool) {
	v := m._USER_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldUSERNAME returns the old USER_NAME value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUSERNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUSERNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUSERNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUSERNAME: %w", err)
	}
	return oldValue.USERNAME, nil
}

// ResetUSERNAME reset all changes of the "USER_NAME" field.
func (m *UserMutation) ResetUSERNAME() {
	m._USER_NAME = nil
}

// SetPASSWORD sets the PASSWORD field.
func (m *UserMutation) SetPASSWORD(s string) {
	m._PASSWORD = &s
}

// PASSWORD returns the PASSWORD value in the mutation.
func (m *UserMutation) PASSWORD() (r string, exists bool) {
	v := m._PASSWORD
	if v == nil {
		return
	}
	return *v, true
}

// OldPASSWORD returns the old PASSWORD value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPASSWORD(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPASSWORD is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPASSWORD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPASSWORD: %w", err)
	}
	return oldValue.PASSWORD, nil
}

// ResetPASSWORD reset all changes of the "PASSWORD" field.
func (m *UserMutation) ResetPASSWORD() {
	m._PASSWORD = nil
}

// SetPositionID sets the position edge to Role by id.
func (m *UserMutation) SetPositionID(id int) {
	m.position = &id
}

// ClearPosition clears the position edge to Role.
func (m *UserMutation) ClearPosition() {
	m.clearedposition = true
}

// PositionCleared returns if the edge position was cleared.
func (m *UserMutation) PositionCleared() bool {
	return m.clearedposition
}

// PositionID returns the position id in the mutation.
func (m *UserMutation) PositionID() (id int, exists bool) {
	if m.position != nil {
		return *m.position, true
	}
	return
}

// PositionIDs returns the position ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PositionID instead. It exists only for internal usage by the builders.
func (m *UserMutation) PositionIDs() (ids []int) {
	if id := m.position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPosition reset all changes of the "position" edge.
func (m *UserMutation) ResetPosition() {
	m.position = nil
	m.clearedposition = false
}

// AddBookingIDs adds the booking edge to Booking by ids.
func (m *UserMutation) AddBookingIDs(ids ...int) {
	if m.booking == nil {
		m.booking = make(map[int]struct{})
	}
	for i := range ids {
		m.booking[ids[i]] = struct{}{}
	}
}

// RemoveBookingIDs removes the booking edge to Booking by ids.
func (m *UserMutation) RemoveBookingIDs(ids ...int) {
	if m.removedbooking == nil {
		m.removedbooking = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooking[ids[i]] = struct{}{}
	}
}

// RemovedBooking returns the removed ids of booking.
func (m *UserMutation) RemovedBookingIDs() (ids []int) {
	for id := range m.removedbooking {
		ids = append(ids, id)
	}
	return
}

// BookingIDs returns the booking ids in the mutation.
func (m *UserMutation) BookingIDs() (ids []int) {
	for id := range m.booking {
		ids = append(ids, id)
	}
	return
}

// ResetBooking reset all changes of the "booking" edge.
func (m *UserMutation) ResetBooking() {
	m.booking = nil
	m.removedbooking = nil
}

// AddAddbyIDs adds the addby edge to Book by ids.
func (m *UserMutation) AddAddbyIDs(ids ...int) {
	if m.addby == nil {
		m.addby = make(map[int]struct{})
	}
	for i := range ids {
		m.addby[ids[i]] = struct{}{}
	}
}

// RemoveAddbyIDs removes the addby edge to Book by ids.
func (m *UserMutation) RemoveAddbyIDs(ids ...int) {
	if m.removedaddby == nil {
		m.removedaddby = make(map[int]struct{})
	}
	for i := range ids {
		m.removedaddby[ids[i]] = struct{}{}
	}
}

// RemovedAddby returns the removed ids of addby.
func (m *UserMutation) RemovedAddbyIDs() (ids []int) {
	for id := range m.removedaddby {
		ids = append(ids, id)
	}
	return
}

// AddbyIDs returns the addby ids in the mutation.
func (m *UserMutation) AddbyIDs() (ids []int) {
	for id := range m.addby {
		ids = append(ids, id)
	}
	return
}

// ResetAddby reset all changes of the "addby" edge.
func (m *UserMutation) ResetAddby() {
	m.addby = nil
	m.removedaddby = nil
}

// AddBorrowIDs adds the borrow edge to Bookborrow by ids.
func (m *UserMutation) AddBorrowIDs(ids ...int) {
	if m.borrow == nil {
		m.borrow = make(map[int]struct{})
	}
	for i := range ids {
		m.borrow[ids[i]] = struct{}{}
	}
}

// RemoveBorrowIDs removes the borrow edge to Bookborrow by ids.
func (m *UserMutation) RemoveBorrowIDs(ids ...int) {
	if m.removedborrow == nil {
		m.removedborrow = make(map[int]struct{})
	}
	for i := range ids {
		m.removedborrow[ids[i]] = struct{}{}
	}
}

// RemovedBorrow returns the removed ids of borrow.
func (m *UserMutation) RemovedBorrowIDs() (ids []int) {
	for id := range m.removedborrow {
		ids = append(ids, id)
	}
	return
}

// BorrowIDs returns the borrow ids in the mutation.
func (m *UserMutation) BorrowIDs() (ids []int) {
	for id := range m.borrow {
		ids = append(ids, id)
	}
	return
}

// ResetBorrow reset all changes of the "borrow" edge.
func (m *UserMutation) ResetBorrow() {
	m.borrow = nil
	m.removedborrow = nil
}

// AddPreemptionIDs adds the preemption edge to Preemption by ids.
func (m *UserMutation) AddPreemptionIDs(ids ...int) {
	if m.preemption == nil {
		m.preemption = make(map[int]struct{})
	}
	for i := range ids {
		m.preemption[ids[i]] = struct{}{}
	}
}

// RemovePreemptionIDs removes the preemption edge to Preemption by ids.
func (m *UserMutation) RemovePreemptionIDs(ids ...int) {
	if m.removedpreemption == nil {
		m.removedpreemption = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpreemption[ids[i]] = struct{}{}
	}
}

// RemovedPreemption returns the removed ids of preemption.
func (m *UserMutation) RemovedPreemptionIDs() (ids []int) {
	for id := range m.removedpreemption {
		ids = append(ids, id)
	}
	return
}

// PreemptionIDs returns the preemption ids in the mutation.
func (m *UserMutation) PreemptionIDs() (ids []int) {
	for id := range m.preemption {
		ids = append(ids, id)
	}
	return
}

// ResetPreemption reset all changes of the "preemption" edge.
func (m *UserMutation) ResetPreemption() {
	m.preemption = nil
	m.removedpreemption = nil
}

// AddRecordIDs adds the record edge to Research by ids.
func (m *UserMutation) AddRecordIDs(ids ...int) {
	if m.record == nil {
		m.record = make(map[int]struct{})
	}
	for i := range ids {
		m.record[ids[i]] = struct{}{}
	}
}

// RemoveRecordIDs removes the record edge to Research by ids.
func (m *UserMutation) RemoveRecordIDs(ids ...int) {
	if m.removedrecord == nil {
		m.removedrecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrecord[ids[i]] = struct{}{}
	}
}

// RemovedRecord returns the removed ids of record.
func (m *UserMutation) RemovedRecordIDs() (ids []int) {
	for id := range m.removedrecord {
		ids = append(ids, id)
	}
	return
}

// RecordIDs returns the record ids in the mutation.
func (m *UserMutation) RecordIDs() (ids []int) {
	for id := range m.record {
		ids = append(ids, id)
	}
	return
}

// ResetRecord reset all changes of the "record" edge.
func (m *UserMutation) ResetRecord() {
	m.record = nil
	m.removedrecord = nil
}

// AddReturnIDs adds the return edge to Bookreturn by ids.
func (m *UserMutation) AddReturnIDs(ids ...int) {
	if m._return == nil {
		m._return = make(map[int]struct{})
	}
	for i := range ids {
		m._return[ids[i]] = struct{}{}
	}
}

// RemoveReturnIDs removes the return edge to Bookreturn by ids.
func (m *UserMutation) RemoveReturnIDs(ids ...int) {
	if m.removed_return == nil {
		m.removed_return = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_return[ids[i]] = struct{}{}
	}
}

// RemovedReturn returns the removed ids of return.
func (m *UserMutation) RemovedReturnIDs() (ids []int) {
	for id := range m.removed_return {
		ids = append(ids, id)
	}
	return
}

// ReturnIDs returns the return ids in the mutation.
func (m *UserMutation) ReturnIDs() (ids []int) {
	for id := range m._return {
		ids = append(ids, id)
	}
	return
}

// ResetReturn reset all changes of the "return" edge.
func (m *UserMutation) ResetReturn() {
	m._return = nil
	m.removed_return = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._USER_EMAIL != nil {
		fields = append(fields, user.FieldUSEREMAIL)
	}
	if m._USER_NAME != nil {
		fields = append(fields, user.FieldUSERNAME)
	}
	if m._PASSWORD != nil {
		fields = append(fields, user.FieldPASSWORD)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUSEREMAIL:
		return m.USEREMAIL()
	case user.FieldUSERNAME:
		return m.USERNAME()
	case user.FieldPASSWORD:
		return m.PASSWORD()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUSEREMAIL:
		return m.OldUSEREMAIL(ctx)
	case user.FieldUSERNAME:
		return m.OldUSERNAME(ctx)
	case user.FieldPASSWORD:
		return m.OldPASSWORD(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUSEREMAIL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUSEREMAIL(v)
		return nil
	case user.FieldUSERNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUSERNAME(v)
		return nil
	case user.FieldPASSWORD:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPASSWORD(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUSEREMAIL:
		m.ResetUSEREMAIL()
		return nil
	case user.FieldUSERNAME:
		m.ResetUSERNAME()
		return nil
	case user.FieldPASSWORD:
		m.ResetPASSWORD()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.position != nil {
		edges = append(edges, user.EdgePosition)
	}
	if m.booking != nil {
		edges = append(edges, user.EdgeBooking)
	}
	if m.addby != nil {
		edges = append(edges, user.EdgeAddby)
	}
	if m.borrow != nil {
		edges = append(edges, user.EdgeBorrow)
	}
	if m.preemption != nil {
		edges = append(edges, user.EdgePreemption)
	}
	if m.record != nil {
		edges = append(edges, user.EdgeRecord)
	}
	if m._return != nil {
		edges = append(edges, user.EdgeReturn)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePosition:
		if id := m.position; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeBooking:
		ids := make([]ent.Value, 0, len(m.booking))
		for id := range m.booking {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAddby:
		ids := make([]ent.Value, 0, len(m.addby))
		for id := range m.addby {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBorrow:
		ids := make([]ent.Value, 0, len(m.borrow))
		for id := range m.borrow {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePreemption:
		ids := make([]ent.Value, 0, len(m.preemption))
		for id := range m.preemption {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRecord:
		ids := make([]ent.Value, 0, len(m.record))
		for id := range m.record {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReturn:
		ids := make([]ent.Value, 0, len(m._return))
		for id := range m._return {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedbooking != nil {
		edges = append(edges, user.EdgeBooking)
	}
	if m.removedaddby != nil {
		edges = append(edges, user.EdgeAddby)
	}
	if m.removedborrow != nil {
		edges = append(edges, user.EdgeBorrow)
	}
	if m.removedpreemption != nil {
		edges = append(edges, user.EdgePreemption)
	}
	if m.removedrecord != nil {
		edges = append(edges, user.EdgeRecord)
	}
	if m.removed_return != nil {
		edges = append(edges, user.EdgeReturn)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBooking:
		ids := make([]ent.Value, 0, len(m.removedbooking))
		for id := range m.removedbooking {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAddby:
		ids := make([]ent.Value, 0, len(m.removedaddby))
		for id := range m.removedaddby {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBorrow:
		ids := make([]ent.Value, 0, len(m.removedborrow))
		for id := range m.removedborrow {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePreemption:
		ids := make([]ent.Value, 0, len(m.removedpreemption))
		for id := range m.removedpreemption {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRecord:
		ids := make([]ent.Value, 0, len(m.removedrecord))
		for id := range m.removedrecord {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReturn:
		ids := make([]ent.Value, 0, len(m.removed_return))
		for id := range m.removed_return {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedposition {
		edges = append(edges, user.EdgePosition)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePosition:
		return m.clearedposition
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgePosition:
		m.ClearPosition()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePosition:
		m.ResetPosition()
		return nil
	case user.EdgeBooking:
		m.ResetBooking()
		return nil
	case user.EdgeAddby:
		m.ResetAddby()
		return nil
	case user.EdgeBorrow:
		m.ResetBorrow()
		return nil
	case user.EdgePreemption:
		m.ResetPreemption()
		return nil
	case user.EdgeRecord:
		m.ResetRecord()
		return nil
	case user.EdgeReturn:
		m.ResetReturn()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
